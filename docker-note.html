<!-- build time:Tue Oct 12 2021 16:36:11 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script></script><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="-ZrQ5_gvorSDz6GoISTGIBaTjef2c3TFVkPfrA3d3XQ"><meta name="yandex-verification" content="be23233c5033cd4a"><meta name="baidu-site-verification" content="KFXVdNKQ18"><meta name="360-site-verification" content="bbd6f1a0727d8ef429be7131a051be20"><meta name="shenma-site-verification" content="719fb1b0c8f713194c5ac0387ee88673_1519303685"><meta name="msvalidate.01" content="EA3043B3BEC4629344CE5A71597718A0"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="Docker,"><link rel="alternate" href="/atom.xml" title="My Sunshine" type="application/atom+xml"><meta name="description" content="学习总结来自 Gitbook Docker 从入门到实践的总结；现在容器的工具太多，国内阿里，华为等都有自己的容器产品，说到容器大多数想到或者用到的是 Docker，所以就这样来学习吧。主要学习方向参考上面的书。这篇书讲得很全，作为开发人员可以刚开始不用全部都学习完，只是把基础的内容学习一遍，加上尝试实践，和中间学习过程中感觉到理解困难的学习点记录了下，最主要还是注重基础，有 shell 脚本基础"><meta name="keywords" content="Docker"><meta property="og:type" content="article"><meta property="og:title" content="学习 Docker 笔记"><meta property="og:url" content="http://blog.wuwii.com/docker-note.html"><meta property="og:site_name" content="My Sunshine"><meta property="og:description" content="学习总结来自 Gitbook Docker 从入门到实践的总结；现在容器的工具太多，国内阿里，华为等都有自己的容器产品，说到容器大多数想到或者用到的是 Docker，所以就这样来学习吧。主要学习方向参考上面的书。这篇书讲得很全，作为开发人员可以刚开始不用全部都学习完，只是把基础的内容学习一遍，加上尝试实践，和中间学习过程中感觉到理解困难的学习点记录了下，最主要还是注重基础，有 shell 脚本基础"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://zqnight.gitee.io/kaimz.github.io/image/hexo/docker/network.png"><meta property="og:image" content="https://docs.docker.com/engine/swarm/images/swarm-diagram.png"><meta property="og:image" content="https://docs.docker.com/engine/swarm/images/services-diagram.png"><meta property="og:updated_time" content="2019-12-15T15:02:50.213Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="学习 Docker 笔记"><meta name="twitter:description" content="学习总结来自 Gitbook Docker 从入门到实践的总结；现在容器的工具太多，国内阿里，华为等都有自己的容器产品，说到容器大多数想到或者用到的是 Docker，所以就这样来学习吧。主要学习方向参考上面的书。这篇书讲得很全，作为开发人员可以刚开始不用全部都学习完，只是把基础的内容学习一遍，加上尝试实践，和中间学习过程中感觉到理解困难的学习点记录了下，最主要还是注重基础，有 shell 脚本基础"><meta name="twitter:image" content="https://zqnight.gitee.io/kaimz.github.io/image/hexo/docker/network.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!0,onmobile:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"TWXZ15WRBL",apiKey:"c272bd4b810c8b43773a3f1d3c6b8d27",indexName:"wuwii",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.wuwii.com/docker-note.html"><link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#1f94aa"><title>学习 Docker 笔记 | My Sunshine</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b847762b9271725a63131e554978de0a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(){var e=document.createElement("script");e.src="//tajs.qq.com/stats?sId=63798915";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link href="https://zqnight.gitee.io/kaimz.github.io/css/harlem-shake-style.css" rel="stylesheet" type="text/css"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><div class="forkme"><a rel="external nofollow noopener noreferrer" href="https://github.com/kaimz" target="_blank"><img style="position:absolute;top:0;left:0;border:0" src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png" alt="Fork me on GitHub"></a></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">My Sunshine</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">鸣谢生命有你参与 笑纳我的邀请。</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav><canvas id="wobblew" width="1056" height="150" style="position:absolute;z-index:-1;left:0;top:0"></canvas></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.wuwii.com/docker-note.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Kai Zhang"><meta itemprop="description" content=""><meta itemprop="image" content="https://oss.wuwii.com/image/head/%E6%97%A0%E9%99%90.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Sunshine"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">学习 Docker 笔记</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-13T22:12:03+08:00">2018-04-13 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">14,816 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">62</span></div></div></header><div class="post-body" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>学习总结来自 Gitbook <a href="https://yeasy.gitbooks.io/docker_practice/content/basic_concept/image.html" rel="external nofollow noopener noreferrer" target="_blank">Docker 从入门到实践的总结</a>；<br>现在容器的工具太多，国内阿里，华为等都有自己的容器产品，说到容器大多数想到或者用到的是 Docker，所以就这样来学习吧。主要学习方向参考上面的书。</p><p>这篇书讲得很全，作为开发人员可以刚开始不用全部都学习完，只是把基础的内容学习一遍，加上尝试实践，和中间学习过程中感觉到理解困难的学习点记录了下，最主要还是注重基础，有 <em>shell</em> 脚本基础学习起来时要轻松很多，重点是理解原理，有条件加以实战，才知道原来是这样啊，也能发现发现很多问题。</p><a id="more"></a><h2 id="为什么要使用-Docker"><a href="#为什么要使用-Docker" class="headerlink" title="为什么要使用 Docker"></a>为什么要使用 Docker</h2><h3 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h3><p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><h3 id="为什么要用-Docker"><a href="#为什么要用-Docker" class="headerlink" title="为什么要用 Docker"></a>为什么要用 Docker</h3><ol><li>更高效的利用系统资源</li><li>更高效的利用系统资源：直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</li><li>一致的运行环境</li><li>持续交付和部署，一次创建或配置，可以在任意地方正常运行。</li><li>更轻松的迁移，可以多平台运行。</li><li>更轻松的维护和扩展，可以自定义镜像。</li></ol><h2 id="了解-Docker-的基本概念"><a href="#了解-Docker-的基本概念" class="headerlink" title="了解 Docker 的基本概念"></a>了解 Docker 的基本概念</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>Docker 设计时，充分利用 Union FS 的技术，将其设计为分层存储的架构。镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器是镜像运行时的实体，只是是以镜像为基础层，在其上创建一个当前<strong>容器的存储层</strong>。容器可以被创建、启动、停止、删除、暂停等。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>参考 <a href="https://blog.wuwii.com/docker-install.html">安装 Docker</a></p><h3 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h3><p>国内使用加速：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="镜像-1"><a href="#镜像-1" class="headerlink" title="镜像"></a>镜像</h3><h4 id="查找镜像语法"><a href="#查找镜像语法" class="headerlink" title="查找镜像语法"></a>查找镜像语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><p><strong>–automated :</strong>只列出 automated build类型的镜像；</p></li><li><p><strong>–no-trunc :</strong>显示完整的镜像描述；</p></li><li><p><strong>-s :</strong>列出收藏数不小于指定值的镜像。</p></li></ul><p>我们首先想使用某个镜像，就可以去 DockerHub 下载，首先去查找镜像，例如我想使用 <code>nginx</code> 镜像并且收藏数大于100：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker search nginx -s 100</span><br><span class="line">Flag --stars has been deprecated, use --filter=stars=3 instead</span><br><span class="line">NAME                                     DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">nginx                                    Official build of Nginx.                        8309                [OK]                </span><br><span class="line">jwilder/nginx-proxy                      Automated Nginx reverse proxy <span class="keyword">for</span> docker con…   1312                                    [OK]</span><br><span class="line">richarvey/nginx-php-fpm                  Container running Nginx + PHP-FPM capable of…   544                                     [OK]</span><br><span class="line">jrcs/letsencrypt-nginx-proxy-companion   LetsEncrypt container to use with nginx as p…   341                                     [OK]</span><br><span class="line">kong                                     Open-source Microservice &amp; API Management la…   173                 [OK]</span><br></pre></td></tr></table></figure><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>从 Docker 的镜像仓库中拖取镜像 <code>docker pull</code>：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><p></p><p>获取 nginx 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull nginx:latest</span><br></pre></td></tr></table></figure><h4 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h4><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令，或者 <code>docker images</code>，它会列出所有的镜像。<br>列表包含了 仓库名、标签、镜像 ID（唯一标识）、创建时间 以及 所占用的空间。</p><p>当然命令后面可以接条件，找出符合条件的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>OPTIONS说明：</p><ul><li><strong>-a :</strong>列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li><li><strong>–digests :</strong>显示镜像的摘要信息；</li><li><strong>-f :</strong>显示满足条件的镜像；</li><li><strong>–format :</strong>指定返回值的模板文件；</li><li><strong>–no-trunc :</strong>显示完整的镜像信息；</li><li><strong>-q :</strong>只显示镜像ID。</li></ul><p>合理的格式获取镜像的参数，可以方便在脚本中的使用。</p><p>查看 nginx 镜像的 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls nginx:latest -q</span><br><span class="line">c5c4e8fa2cf7</span><br></pre></td></tr></table></figure><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><ol><li><p>使用 ID 删除镜像：上面我们查看到 nginx 的 id 很长，但是实际上只要使用前三位以后能够确定到哪个镜像就行了 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm c5c</span><br></pre></td></tr></table></figure></li><li><p>使用镜像名删除镜像：也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm nginx:latest</span><br></pre></td></tr></table></figure></li><li><p>使用镜像摘要删除镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ docker image ls nginx --digests</span><br><span class="line">REPOSITORY          TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              sha256:e36d7f5dabf1429d84135bb8a8086908e1150f1a178c75719a9e0e53ebb90353   c5c4e8fa2cf7        6 days ago          109MB</span><br><span class="line"></span><br><span class="line">$ docker image rm nginx@sha256:e36d7f5dabf1429d84135bb8a8086908e1150f1a178c75719a9e0e53ebb90353</span><br><span class="line">Untagged: nginx@sha256:e36d7f5dabf1429d84135bb8a8086908e1150f1a178c75719a9e0e53ebb90353</span><br></pre></td></tr></table></figure></li></ol><p>现在我们就可以使用查询命令来配合使用删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker image rm $(docker image ls nginx -q)</span><br><span class="line">Untagged: nginx:latest</span><br><span class="line">Untagged: nginx@sha256:e36d7f5dabf1429d84135bb8a8086908e1150f1a178c75719a9e0e53ebb90353</span><br><span class="line">Deleted: sha256:c5c4e8fa2cf7d87545ed017b60a4b71e047e26c4ebc71eb1709d9e5289f9176f</span><br><span class="line">Deleted: sha256:df08705f06272d44ac0364419532e581af1340fc54ef33423d3735abba422834</span><br><span class="line">Deleted: sha256:220ece772fae32240b2b8491a072c7b30cc0c5c6b67ad73fba6c2968e4ecacd7</span><br></pre></td></tr></table></figure><hr><h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><p>给一个镜像打上指定的标签（它们拥有一样的 IMAGE ID，可以试一试）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag nginx:latest kronchan/nginx:v1.0 </span><br><span class="line">$ docker image ls kronchan/nginx:v1.0        </span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">kronchan/nginx      v1.0                c5c4e8fa2cf7        6 days ago          109MB</span><br></pre></td></tr></table></figure><p><strong>但是多个镜像有相同 ID 不能使用 ID 一次性删除：</strong><code>Error response from daemon: conflict: unable to delete c5c4e8fa2cf7 (must be forced) - image is referenced in multiple repositories</code></p><h4 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h4><p><code>Dockerfile</code>是由一系列命令和参数构成的脚本，一个<code>Dockerfile</code>里面包含了构建整个<code>image</code>的完整命令。Docker通过<code>docker build</code>执行<code>Dockerfile</code>中的一系列命令自动构建<code>image</code>。</p><h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h5><p>所谓定制镜像，那一定是以一个镜像为基础，比如我们需要构建一个 java 项目，就必须要在 java 环境的基础上进行构建，其中基础镜像是必须指定的，<code>FROM</code> 就是指定<strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[:tag]</span><br></pre></td></tr></table></figure><h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ol><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，直接追加 shell 命令行；</li><li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ol><p>比如给 nginx 制定欢迎页的 <code>Dockerfile</code>：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure><p>在文件所在目录执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v1.0 .</span><br></pre></td></tr></table></figure><p>注意后面的点不能少，点 <code>.</code> 表示使用当前目录作为上下文环境将文件进行打包，上传到 Docker 引擎服务器，进行构建镜像。</p><h5 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h5><p>格式：</p><ul><li><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br></pre></td></tr></table></figure><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match" rel="external nofollow noopener noreferrer" target="_blank"><code>filepath.Match</code></a> 规则，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><h5 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h5><p>一般认为拥有和 <code>COPY</code> 一样的功能，但是多了一个自动解压缩的功能。</p><h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><p>容器启动命令，其格式有两种：</p><ol><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，直接追加 shell 命令行；</li><li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li></ol><p>在启动容器的时候，可以使用下面命令覆盖<code>CMD</code> 缺省值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run [OPTIONS] IMAGE[:TAG] [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><h5 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h5><p>它指定了当container执行时，需要启动哪些进程。</p><p>两种形式：</p><ul><li>ENTRYPOINT [“executable”, “param1”, “param2”] （<em>exec</em> 形式, 首选）</li><li>ENTRYPOINT command param1 param2 (<em>shell</em> 形式)</li></ul><p><em>shell</em> 形式防止使用任何<code>CMD</code>或运行命令行参数，但是缺点是您的<code>ENTRYPOINT</code>将作<code>/bin/sh -c</code>的子命令启动，它不传递信号。这意味着可执行文件将不是容器的<code>PID 1</code>，并且不会接收Unix信号，因此您的可执行文件将不会从<code>docker stop &lt;container&gt;</code>接收到<code>SIGTERM</code>。</p><p>只有<code>Dockerfile</code>中最后一个<code>ENTRYPOINT</code>指令会有效果。</p><p><code>docker run &lt;image&gt;</code>的命令行参数将附跟在 <em>exec</em> 形式的<code>ENTRYPOINT</code>中的所有元素之后，并将覆盖使用<code>CMD</code>指定的所有元素。这允许将参数传递到入口点，即<code>docker run &lt;image&gt; -d</code>将把<code>-d</code>参数传递给入口点。</p><p>入口点，和 <code>CMD</code> 一起使用比较好，</p><p>例子：</p><p>编写一个 <code>Dockerfile</code>:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"top"</span>, <span class="string">"-b"</span>]</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"-c"</span>]</span></span><br></pre></td></tr></table></figure><p>构建镜像，分别运行两个容器：</p><ol><li><code>$ docker run -d --name test1 test/ubuntu:v1.0</code></li><li><code>$ docker run -d --name test2 test/ubuntu:v1.0 -H</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE                         COMMAND                  CREATED             STATUS                  PORTS                    NAMES</span><br><span class="line">de2ac31d1219        <span class="built_in">test</span>/ubuntu:v1.0              <span class="string">"top -b -H"</span>              2 minutes ago       Up 2 minutes                                     test2</span><br><span class="line">852e5d5119d0        <span class="built_in">test</span>/ubuntu:v1.0              <span class="string">"top -b -c"</span>              3 minutes ago       Up 3 minutes                                     test1</span><br></pre></td></tr></table></figure><p>可以检查容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it test2 ps aux </span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.1  36520  1584 ?        Ss   04:04   0:00 top -b -H</span><br><span class="line">root         5  0.0  0.1  34412  1436 pts/0    Rs+  04:15   0:00 ps aux</span><br></pre></td></tr></table></figure><p>启动容器的时候可以使用 <code>--entrypoint=&quot;&quot;: Overwrite the default entrypoint set by the image</code>，覆盖缺省的值。</p><p>TODO ，这方面还需要再了解下。</p><h5 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h5><p>格式有两种：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>设置环境变量，后面可以直接调用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> VERSION=<span class="number">1.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$VERSION</span></span></span><br></pre></td></tr></table></figure><p><code>-e</code>参数：在启动容器 的时候使用 <code>-e VERSION=2.0</code> 可以覆盖值。</p><p>在容器启动的时候，会缺省创建下面的变量：</p><table><thead><tr><th><strong>Variable</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td><code>HOME</code></td><td>Set based on the value of <code>USER</code></td></tr><tr><td><code>HOSTNAME</code></td><td>The hostname associated with the container</td></tr><tr><td><code>PATH</code></td><td>Includes popular directories, such as :<code>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</code></td></tr><tr><td><code>TERM</code></td><td><code>xterm</code> if the container is allocated a psuedo-TTY</td></tr></tbody></table><h5 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h5><p>构建参数，格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><h5 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h5><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p>一般上，容器是不保存任何文件的，因为容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>我们将这些动态数据挂载到主机中，就可以使用挂载卷保存数据。也可以在运行的时候覆盖挂载卷的参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit -v mydata:/data image</span><br></pre></td></tr></table></figure><p><code>mydata</code> 为 宿主中的挂载卷，将会挂载到 docker 容器中的 data 这个文件夹中，而且会覆盖 Dockerfile 中设置的匿名挂载卷。</p><h5 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h5><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p>这只是一个<strong>声明</strong>，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code>时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>运行时使用命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run d -p 8001:8000 IMAGE</span><br></pre></td></tr></table></figure><p>其中 docker 容器的 8000 端口映射到宿主 8000 端口。</p><p>使用 <code>-P</code> 将内部容器所有开放的端口随机分发，你可以使用docker port来查找这个随机绑定端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--expose=[]: Expose a port or a range of ports from the container</span><br><span class="line">            without publishing it to your host</span><br><span class="line">-P=<span class="literal">false</span>   : Publish all exposed ports to the host interfaces</span><br><span class="line">-p=[]      : Publish a container᾿s port to the host (format:</span><br><span class="line">             ip:hostPort:containerPort | ip::containerPort |</span><br><span class="line">             hostPort:containerPort | containerPort)</span><br><span class="line">             (use <span class="string">'docker port'</span> to see the actual mapping)</span><br><span class="line">--link=<span class="string">""</span>  : Add link to another container (name:<span class="built_in">alias</span>)</span><br></pre></td></tr></table></figure><h5 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h5><p>区别于 <em>shell</em> 中的 <code>cd</code>的切换命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /app</span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"hello"</span> &gt; world.txt</span></span><br></pre></td></tr></table></figure><p>由于 Dockerfile 中每个 RUN 都是开启一个容器，所以第二行的命令重启一个容器又是一个新的环境，把那个不知道你切换了文件目录，它还是在原来的位置。如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p><p>启动容器的时候可以使用 <code>-w</code>覆盖默认缺省值。</p><h5 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h5><p>格式：<code>USER &lt;用户名 or UID&gt;</code></p><p><code>USER</code> 改变后面构建层使用命令的<strong>身份</strong>，这个用户必须是事先建立好的，否则无法切换。</p><p>启动容器的时候可以使用<code>-u</code>覆盖缺省值。</p><h5 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h5><p>格式：<code>MAINTAINER [name]</code></p><p><code>MAINTAINER</code>指令允许您设置生成的images的作者字段。</p><h5 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h5><p>// todo</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p><code>docker build</code>命令从<code>Dockerfile</code>和<code>context</code>构建image。<code>context</code>是<code>PATH</code>或<code>URL</code>处的文件。<code>PATH</code>本地文件目录。 <code>URL</code>是Git repository的位置。</p><p><code>context</code>以递归方式处理。因此，<code>PATH</code>包括任何子目录，<code>URL</code>包括repository及submodules。一个使用当前目录作为<code>context</code>的简单构建命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build .</span><br><span class="line">Sending build context to Docker daemon  6.51 MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>构建由Docker守护程序运行，而不是由CLI运行。构建过程所做的第一件事是将整个context（递归地）发送给守护进程。大多数情况下，最好是将<code>Dockerfile</code>和所需文件复制到一个空的目录，再到这个目录进行构建。</p><blockquote><p><code>警告</code>：不要使用根目录<code>/</code>作为PATH，因为它会导致构建将硬盘驱动器的所有内容传输到Docker守护程序。</p></blockquote><p>可以使用<code>.dockerignore</code>文件添加到<code>context</code>目录中来排除文件和目录。</p><p>一般的，<code>Dockerfile</code>位于<code>context</code>的根中。但使用<code>-f</code>标志可指定Dockerfile的位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -f /path/to/a/Dockerfile .</span><br></pre></td></tr></table></figure><p>如果build成功，您可以指定要保存新image的repository和tag：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t shykes/myapp .</span><br></pre></td></tr></table></figure><p>要在构建后将image标记为多个repositories，请在运行构建命令时添加多个<code>-t</code>参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .</span><br></pre></td></tr></table></figure><p>Docker守护程序一个接一个地运行<code>Dockerfile</code>中的指令，如果需要，将每个指令的结果提交到一个新image，最后输出新映像的ID。Docker守护进程将自动清理您发送的context。</p><p>请注意，每个指令独立运行，并导致创建一个新image - 因此<code>RUN cd /tmp</code>对下一个指令不会有任何影响。</p><p>只要有可能，Docker将重新使用中间images（缓存），就是以前构建镜像使用过的指令再次重复使用，加速<code>docker build</code>过程。</p><h5 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h5><p>写一个简单的 Dockerfile：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my demo</span></span><br><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">MAINTAINER</span> kronchan1@gmail.com</span><br><span class="line"><span class="keyword">ENV</span> MKDIR=new-file \</span><br><span class="line">    FILE=tmpfile</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /kronchan</span></span><br><span class="line"><span class="bash">RUN mkdir <span class="variable">$&#123;MKDIR&#125;</span> \</span></span><br><span class="line"><span class="bash">    &amp;&amp; touch <span class="variable">$&#123;MKDIR&#125;</span>/<span class="variable">$&#123;FILE&#125;</span></span></span><br><span class="line"><span class="bash">COPY file1.tar.gz .</span></span><br><span class="line"><span class="bash">ADD file2.tar .</span></span><br></pre></td></tr></table></figure><p>开始构建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">Dockerfile  file1.tar.gz  file2.tar</span><br><span class="line"><span class="comment"># 开始构建镜像</span></span><br><span class="line">$ docker build -t <span class="built_in">test</span>-image .</span><br><span class="line">Sending build context to Docker daemon  3.072kB</span><br><span class="line">Step 1/7 : FROM busybox</span><br><span class="line"> ---&gt; 8ac48589692a</span><br><span class="line">Step 2/7 : MAINTAINER kronchan1@gmail.com</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; ca58745123bb</span><br><span class="line">Step 3/7 : ENV MKDIR=new-file     FILE=tmpfile</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; f6383692900a</span><br><span class="line">Step 4/7 : WORKDIR /kronchan</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; f1f4e917cdcf</span><br><span class="line">Step 5/7 : RUN mkdir <span class="variable">$&#123;MKDIR&#125;</span>     &amp;&amp; touch <span class="variable">$&#123;MKDIR&#125;</span>/<span class="variable">$&#123;FILE&#125;</span></span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 28963ac16c41</span><br><span class="line">Step 6/7 : COPY file1.tar.gz .</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; d4f4affd5b88</span><br><span class="line">Step 7/7 : ADD file2.tar .</span><br><span class="line">^[[A ---&gt; f1ba7424ec6e</span><br><span class="line">Successfully built f1ba7424ec6e</span><br><span class="line">Successfully tagged <span class="built_in">test</span>-image:latest</span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">$ docker run -it <span class="built_in">test</span>-image</span><br><span class="line"><span class="comment"># 进入容器后，自动进入创建的工作目录</span></span><br><span class="line">/kronchan <span class="comment"># ls</span></span><br><span class="line">file1.tar.gz  file2.tar     new-file</span><br><span class="line"><span class="comment"># 检查环境变量</span></span><br><span class="line">/kronchan <span class="comment"># echo $FILE</span></span><br><span class="line">tmpfile</span><br></pre></td></tr></table></figure><p><strong>突然发现，<code>ADD</code> 指令好像也不能像前面或者网络上前辈们介绍的说自动解压文件，暂时记录，能力有限，也不能说明白，记录下以后不要踩坑，复制文件还是使用 <code>COPY</code> 语义更标准。</strong></p><h3 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>语法： <code>docker run</code></p><p>启动 nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -dit nginx</span><br></pre></td></tr></table></figure><p><code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，</p><p><code>-i</code> 则让容器的标准输入保持打开。</p><p><code>-d</code> 守护状态运行。</p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p>可以利用 <code>docker container start [container ID or NAMES]</code> 命令，直接将一个已经终止的容器启动运行。</p><p>查看<strong>守护状态运行</strong>的容器的输出信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker logs [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">Fetch the logs of a container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --details        Show extra details provided to logs</span><br><span class="line">  -f, --follow         Follow <span class="built_in">log</span> output</span><br><span class="line">      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m <span class="keyword">for</span> 42 minutes)</span><br><span class="line">      --tail string    Number of lines to show from the end of the logs (default <span class="string">"all"</span>)</span><br><span class="line">  -t, --timestamps     Show timestamps</span><br><span class="line">      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m <span class="keyword">for</span> 42 minutes)</span><br></pre></td></tr></table></figure><h4 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h4><p>可以使用 <code>docker container stop [container ID or NAMES]</code> 来终止一个运行中的容器。</p><h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p><code>exec</code> 命令</p><p>一般使用 <code>-i</code>，<code>-t</code>参数后就可以有终端和提示符。</p><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><ol><li>可以使用 <code>docker container rm [container ID or NAMES]</code> 来删除一个处于终止状态的容器。</li><li>如果需要删除运行状态中的容器，加上参数 <code>-f</code> 强制删除；</li><li><code>$ docker container prune</code> 清理所有处于终止状态的容器。</li></ol><h4 id="导出和导入"><a href="#导出和导入" class="headerlink" title="导出和导入"></a>导出和导入</h4><ol><li><p>导出容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">export</span> 180f &gt; /root/springboot-docker.tar</span><br></pre></td></tr></table></figure></li><li><p>导入容器快照：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import - kronchan/springboot-docker:v1.0</span><br></pre></td></tr></table></figure><p>还可以导入 url 中的文件作为镜像。</p></li></ol><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/" rel="external nofollow noopener noreferrer" target="_blank">Docker Hub</a>，但是国内推送的速度在没有翻墙的情况下比较尴尬，所以可以使用 <a href="https://cr.console.aliyun.com/?spm=a2c4e.11153959.blogcont29941.9.520269d65b5sBo&amp;accounttraceid=7944ca1b-ff8f-4239-91ba-79d103b8e92e#/imageList" rel="external nofollow noopener noreferrer" target="_blank">阿里云镜像服务</a>。</p><ol><li><p>登陆 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login registry.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure><p>然后输入账号密码。</p></li><li><p>标记 TAG（可选）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag [ImageId] com.wuwii/&lt;image&gt;[:镜像版本号]</span><br></pre></td></tr></table></figure></li><li><p>推送：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker push [image]</span><br></pre></td></tr></table></figure></li></ol><h4 id="提交构建文件到仓库"><a href="#提交构建文件到仓库" class="headerlink" title="提交构建文件到仓库"></a>提交构建文件到仓库</h4><p>只需要将构建镜像的 <code>Dockerfile</code> 和其余相关的文件一同 <code>push</code> 到代码托管仓库，再次 <code>push</code> 下来就能重新构建镜像。</p><h3 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h3><h4 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h4><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li><code>数据卷</code> 可以在容器之间共享和重用</li><li>对 <code>数据卷</code> 的修改会立马生效</li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会一直存在，即使容器被删除</li></ul><p><strong>Command：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Usage:  docker volume COMMAND</span><br><span class="line"></span><br><span class="line">Manage volumes</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume </span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volume</span><br><span class="line">  prune       Remove all unused volumes </span><br><span class="line">  rm          Remove one or more volumes</span><br></pre></td></tr></table></figure><h4 id="容器挂载数据卷"><a href="#容器挂载数据卷" class="headerlink" title="容器挂载数据卷"></a>容器挂载数据卷</h4><p>例如我启动一个 <code>jenkins</code> 容器，命名为 <code>my_jenkins</code>，将容器的 <code>var/jenkins_home/</code>目录挂载到数据卷 <code>my_jenkins</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create my_jenkins_volume</span><br><span class="line"></span><br><span class="line">$ docker run -p 7322:8080 -p 50000:50000 -v my_jenkins_volume:/var/jenkins_home/  --name my_jenkins -d jenkins</span><br></pre></td></tr></table></figure><blockquote><p><code>-v my_jenkins_volume:/var/jenkins_home/</code> 可以理解是 <code>--mount source=my_jenkins_volume,target=/var/jenkins_home/</code>，后面一种更好理解，也是推荐使用的。</p></blockquote><p>查询容器信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect my_jenkins</span><br><span class="line"></span><br><span class="line">…………</span><br><span class="line"> <span class="string">"Mounts"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"my_jenkins_volume"</span>,</span><br><span class="line">                <span class="string">"Source"</span>: <span class="string">"/var/lib/docker/volumes/my_jenkins_volume/_data"</span>,</span><br><span class="line">                <span class="string">"Destination"</span>: <span class="string">"/var/jenkins_home"</span>,</span><br><span class="line">                <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">                <span class="string">"Mode"</span>: <span class="string">"z"</span>,</span><br><span class="line">                <span class="string">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">…………</span><br></pre></td></tr></table></figure><h4 id="挂载主机文件作为数据卷"><a href="#挂载主机文件作为数据卷" class="headerlink" title="挂载主机文件作为数据卷"></a>挂载主机文件作为数据卷</h4><p>不光可以将数据卷挂载到容器中，我们还可以直接将宿主的文件直接作为数据卷使用，完成一样的效果。</p><p>上面的，我将宿主的文件夹 <code>/var/my_jenkins</code>，作为数据卷挂载到 <code>/var/my_jenkins</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 7322:8080 -p 50000:50000 -v /var/jenkins_home/:/var/jenkins_home/  --name my_jenkins -d jenkins</span><br></pre></td></tr></table></figure><blockquote><p>也可以用 <code>--mount type=bind,source=/var/jenkins_home/,target=/var/jenkins_home/</code></p></blockquote><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/docker/network.png" alt="image"></p><h4 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h4><p>使用<code>-p</code>和<code>-P</code> 设置主机和容器的映射端口。</p><h4 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h4><p><strong>使用自定义网络 （network）进行互联。</strong></p><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm --name busybox1 --network my-net busybox sh</span><br></pre></td></tr></table></figure><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></table></figure><p>再打开一个新的终端查看容器信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b47060aca56b        busybox             <span class="string">"sh"</span>                11 minutes ago      Up 11 minutes                           busybox2</span><br><span class="line">8720575823ec        busybox             <span class="string">"sh"</span>                16 minutes ago      Up 16 minutes                           busybox1</span><br></pre></td></tr></table></figure><p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><p>在 <code>busybox1</code> 容器输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ping busybox2</span></span><br><span class="line">PING busybox2 (172.19.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms</span><br><span class="line">64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms</span><br></pre></td></tr></table></figure><p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p><p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ # ping busybox1</span><br><span class="line">PING busybox1 (172.19.0.2): 56 data bytes</span><br><span class="line">64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms</span><br><span class="line">64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms</span><br></pre></td></tr></table></figure><p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>在自定义配置文件中加入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dns"</span> : [</span><br><span class="line">    <span class="string">"114.114.114.114"</span>,</span><br><span class="line">    <span class="string">"8.8.8.8"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后每次启动容器都会自动配置上面的 <code>DNS</code>。</p><p>如果用户想要手动指定容器的配置，可以在使用 <code>docker run</code> 命令启动容器时加入如下参数：</p><p><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p><p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p><p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p><blockquote><p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 <code>/etc/resolv.conf</code> 来配置容器。</p></blockquote><h4 id="容器访问外网"><a href="#容器访问外网" class="headerlink" title="容器访问外网"></a>容器访问外网</h4><p>容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sysctl net.ipv4.ip_forward</span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure><p>如果为 0，说明没有开启转发，则需要手动打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sysctl -w net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure><p>如果在启动 Docker 服务的时候设定 <code>--ip-forward=true</code>, Docker 就会自动设定系统的 <code>ip_forward</code> 参数为 1。</p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>Docker镜像在创建之后，往往需要自己手动pull来获取镜像，然后执行run命令来运行。当服务需要用到多种容器，容器之间又产生了各种依赖和连接的时候，部署一个服务的手动操作是令人感到十分厌烦的。</p><p>Dcoker-Compose技术，就是通过一个<code>.yml</code>配置文件，将所有的容器的部署方法、文件映射、容器连接等等一系列的配置写在一个配置文件里，最后只需要执行<code>docker-compose up</code>命令就会像执行脚本一样的去一个个安装容器并自动部署他们，极大的便利了复杂服务的部署。</p><h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。</p><p>首先介绍几个术语。</p><ul><li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。</li></ul><p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>Linux 上默认是没有安装 <code>docker-compose</code>，查看版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version    </span><br><span class="line">-bash: /usr/bin/docker-compose: No such file or directory</span><br></pre></td></tr></table></figure><p>没有安装。</p><p>从 <a href="https://github.com/docker/compose/releases" rel="external nofollow noopener noreferrer" target="_blank">官方 GitHub Release</a> 处直接下载编译好的二进制文件，</p><p>使用二进制包安装，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">$ sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="模板指令"><a href="#模板指令" class="headerlink" title="模板指令"></a>模板指令</h3><p>使用的 <code>version: 3</code></p><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p><blockquote><p><code>注意</code>：YAML布尔值（true，false，yes，no，on，off）必须用引号引起来，以便解析器将其解释为字符串。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  webapp:</span></span><br><span class="line"><span class="attr">    build:</span></span><br><span class="line"><span class="attr">      context:</span> <span class="string">./dir</span> <span class="comment"># Dockerfile所在目录， 或者远程仓库的地址</span></span><br><span class="line"><span class="attr">      dockerfile:</span> <span class="string">Dockerfile-alternate</span> <span class="comment"># 指定 Dockerfile</span></span><br><span class="line"><span class="attr">      args:</span></span><br><span class="line"><span class="attr">        buildno:</span> <span class="number">1</span> <span class="comment"># 只有在构建时候能使用的变量</span></span><br><span class="line"><span class="attr">      cache_from:</span> <span class="comment"># 设置镜像构建名</span></span><br><span class="line">    	<span class="bullet">-</span> <span class="attr">alpine:latest</span> </span><br><span class="line">    	<span class="bullet">-</span> <span class="string">corp/web_app:3.14</span></span><br></pre></td></tr></table></figure><p>build 不能和 image 一起去使用</p><h4 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a>cap_add, cap_drop</h4><p>指定容器的内核能力（capacity）分配。</p><ol><li><p>让容器拥有所有能力：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_add:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ALL</span></span><br></pre></td></tr></table></figure></li><li><p>让容器移除某些能力：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cap_drop:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">NET_ADMIN</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">SYS_ADMIN</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="command"><a href="#command" class="headerlink" title="command"></a>command</h4><p>覆盖容器启动后默认执行的命令。</p><h4 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a>cgroup_parent</h4><p>为容器指定可选的父cgroup。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cgroup_parent:</span> <span class="string">m-executor-abcd</span></span><br></pre></td></tr></table></figure><h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h4><p>指定自定义容器名称，而不是生成的默认名称。</p><blockquote><p>由于Docker容器名称必须是唯一的，因此如果您指定了自定义名称，则无法将服务扩展到1个容器之外。 尝试这样做会导致错误。</p></blockquote><h4 id="devices"><a href="#devices" class="headerlink" title="devices"></a>devices</h4><p>指定设备映射关系。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devices:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"/dev/ttyUSB1:/dev/ttyUSB0"</span></span><br></pre></td></tr></table></figure><h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h4><p>Express之间的依赖关系，有两个效果：</p><ul><li><p><code>docker-compose up</code> 将按照依赖顺序启动服务。 在下面的示例中，db和redis将在web之前启动。</p></li><li><p><code>docker-compose up SERVICE</code> 将自动包含SERVICE的依赖关系。 在以下示例中，docker-compose up web也将创建并启动db和redis。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">db</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">  db:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure><blockquote><p><code>注意</code>：在启动web之前，depends_on不会等待db和redis“就绪”，直到它们被启动。 如果您需要等待服务准备就绪，请参阅控制<a href="https://docs.docker.com/compose/startup-order/" rel="external nofollow noopener noreferrer" target="_blank">启动顺序</a>了解有关此问题的更多信息以及解决问题的策略。</p></blockquote></li></ul><h4 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h4><p>自定义DNS服务器。可以是单个值或列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns:</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"><span class="bullet">  -</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br></pre></td></tr></table></figure><h4 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h4><p>配置 <code>DNS</code> 搜索域。可以是一个值，也可以是一个列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dns_search:</span> <span class="string">example.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns_search:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">domain1.example.com</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">domain2.example.com</span></span><br></pre></td></tr></table></figure><h4 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h4><p>挂载一个或者多个 tmpfs 文件系统到容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tmpfs:</span> <span class="string">/run</span></span><br><span class="line"><span class="attr">tmpfs:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">/run</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">/tmp</span></span><br></pre></td></tr></table></figure><h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h4><p>从文件添加环境变量。可以是单个值或列表。</p><p>如果已使用<code>docker-compose -f FILE</code>指定了一个Compose文件，则<code>env_file</code>中的路径相对于该文件所在的目录。</p><p>在环境中指定的环境变量会覆盖这些值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env_file:</span> <span class="string">.env</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env_file:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">./common.env</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">./apps/web.env</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">/opt/secrets.env</span></span><br></pre></td></tr></table></figure><p>Compose期望env文件中的每一行都处于<code>VAR = VAL</code>格式。 以＃开头的行（即注释）将被忽略，空行也是如此。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set Rails/Rack environment</span></span><br><span class="line"><span class="string">RACK_ENV=development</span></span><br></pre></td></tr></table></figure><blockquote><p><code>注意</code>：如果您的service指定了build选项，则在build过程中将不会自动显示环境文件中定义的变量。 使用build的args子选项来定义构建时环境变量。</p></blockquote><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>设置环境变量。你可以使用数组或字典两种格式。</p><p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="attr">  RACK_ENV:</span> <span class="string">development</span></span><br><span class="line"><span class="attr">  SESSION_SECRET:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">RACK_ENV=development</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">SESSION_SECRET</span></span><br></pre></td></tr></table></figure><h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p><p>仅可以指定内部端口为参数，</p><p>这个标签与Dockerfile中的EXPOSE指令一样，用于指定暴露的端口，但是只是作为一种参考，实际上docker-compose.yml的端口映射还得ports这样的标签。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">expose:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"3000"</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"8000"</span></span><br></pre></td></tr></table></figure><h4 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h4><p>添加主机名的标签，就是往 <code>/etc/hosts</code>文件中添加一些记录，与 <code>Docker client</code> 的 <code>--add-host</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extra_hosts:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"googledns:8.8.8.8"</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">"dockerhub:52.1.157.61"</span></span><br></pre></td></tr></table></figure><p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加相应 host。</p><h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><p>通过命令检查容器是否健康运行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line"><span class="attr">  test:</span> <span class="string">["CMD",</span> <span class="string">"curl"</span><span class="string">,</span> <span class="string">"-f"</span><span class="string">,</span> <span class="string">"http://localhost"</span><span class="string">]</span></span><br><span class="line"><span class="attr">  interval:</span> <span class="number">1</span><span class="string">m30s</span></span><br><span class="line"><span class="attr">  timeout:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">  retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="attr">ubuntu:latest</span></span><br></pre></td></tr></table></figure><h4 id="labels"><a href="#labels" class="headerlink" title="labels"></a>labels</h4><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="string">com.startupteam.description:</span> <span class="string">"webapp for a startup team"</span></span><br><span class="line">  <span class="string">com.startupteam.department:</span> <span class="string">"devops department"</span></span><br><span class="line">  <span class="string">com.startupteam.release:</span> <span class="string">"rc3 for v1.0"</span></span><br></pre></td></tr></table></figure><h4 id="links"><a href="#links" class="headerlink" title="links"></a>links</h4><p>这个标签解决的是容器连接问题，与<code>Docker client</code>的 <code>--link</code>一样效果，会连接到其它服务中的容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">links:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">db</span></span><br><span class="line"><span class="attr"> - db:</span><span class="string">database</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure><p>使用的别名将会自动在服务容器中的/etc/hosts里创建。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">172.12.2.186  db</span><br><span class="line">172.12.2.186  database</span><br><span class="line">172.12.2.187  redis</span><br></pre></td></tr></table></figure><p>相应的环境变量也将被创建。</p><h4 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h4><p>配置日志选项。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  driver:</span> <span class="string">syslog</span></span><br><span class="line"><span class="attr">  options:</span></span><br><span class="line"><span class="attr">    syslog-address:</span> <span class="string">"tcp://192.168.0.42:123"</span></span><br></pre></td></tr></table></figure><p>目前支持三种日志驱动类型。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver:</span> <span class="string">"json-file"</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">"syslog"</span></span><br><span class="line"><span class="attr">driver:</span> <span class="string">"none"</span></span><br></pre></td></tr></table></figure><p><code>options</code> 配置日志驱动的相关参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">options:</span></span><br><span class="line"><span class="attr">  max-size:</span> <span class="string">"200k"</span></span><br><span class="line"><span class="attr">  max-file:</span> <span class="string">"10"</span></span><br></pre></td></tr></table></figure><h4 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h4><p>设置网络模式。使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network_mode:</span> <span class="string">"bridge"</span> <span class="comment"># 桥接模式，这种模式下， docker 会默认创建一个 docker0 的网桥，从它中分配 ip 提供给容器使用</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"host"</span> <span class="comment"># 使用主机网络</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"none"</span> <span class="comment"># 只能访问本地网络，不能使用外网</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"service:[service name]"</span> <span class="comment"># 与其他某个 service 共享一个网络</span></span><br><span class="line"><span class="attr">network_mode:</span> <span class="string">"container:[container name/id]"</span> <span class="comment"># 与其他某个容器共享一个网络</span></span><br></pre></td></tr></table></figure><h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h4><p>配置容器连接的网络。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  some-service:</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">some-network</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">other-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  some-network:</span></span><br><span class="line"><span class="attr">  other-network:</span></span><br></pre></td></tr></table></figure><h4 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h4><p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pid:</span> <span class="string">"host"</span></span><br></pre></td></tr></table></figure><h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h4><p>暴露端口信息。</p><p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000:8000&quot;</span><br><span class="line"> - &quot;49100:22&quot;</span><br><span class="line"> - &quot;127.0.0.1:8001:8001&quot;</span><br></pre></td></tr></table></figure><p><em>注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p><h4 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a>secrets</h4><p>Docker命令行工具提供了<code>docker secret</code>命令来管理敏感信息，</p><p>从 Docker Compose V3.1开始，支持在容器编排文件中使用 secret，这可以方便地在不同容器中分享所需的敏感信息。</p><p><strong><code>docker secret</code> 只能从<code>Docker Swarm</code>模式的<code>manager</code>节点调用，如果你在本机进行试验，请先执行 <code>docker swarm init</code>命令</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker secret --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage:    docker secret COMMAND</span><br><span class="line"></span><br><span class="line">Manage Docker secrets</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --<span class="built_in">help</span>   Print usage</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create      Create a secret from a file or STDIN as content</span><br><span class="line">  inspect     Display detailed information on one or more secrets</span><br><span class="line">  ls          List secrets</span><br><span class="line">  rm          Remove one or more secrets</span><br></pre></td></tr></table></figure><p>创建一个数据库密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"kronchan"</span> |  docker secret create db_password -</span><br><span class="line">yxadqo4xguucuyhd9oxc5t4q2</span><br><span class="line">$ docker secret ls</span><br><span class="line">ID                          NAME                DRIVER              CREATED             UPDATED</span><br><span class="line">yxadqo4xguucuyhd9oxc5t4q2   db_password                             3 seconds ago       3 seconds ago</span><br></pre></td></tr></table></figure><p>在服务编排中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="attr">    MYSQL_ROOT_PASSWORD_FILE:</span> <span class="string">/run/secrets/db_password</span> <span class="comment"># 缺省值</span></span><br><span class="line"><span class="attr">  secrets:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">db_password</span></span><br></pre></td></tr></table></figure><p>在 Swarm 集群中 ，例如，我用这个密码启动一个 MYSQL 服务，在 manage 节点中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">        --name mysql \</span><br><span class="line">        --secret <span class="built_in">source</span>=db_password,target=mysql_root_password \</span><br><span class="line">        -e MYSQL_ROOT_PASSWORD_FILE=<span class="string">"/run/secrets/mysql_root_password"</span> \</span><br><span class="line">        mysql:latest</span><br></pre></td></tr></table></figure><p>这个过程分为两个步骤：</p><ol><li><code>source</code> 指定容器使用 secret 后，secret 会被解密并存放到<strong>容器的文件系统</strong>中，默认位置为 <code>/run/secrets/&lt;secret_name&gt;</code>，可以使用 <code>target</code> 重新定位。</li><li>设置环境变量 <code>MYSQL_ROOT_PASSWORD_FILE</code> 指定从 <code>/run/secrets/mysql_root_password</code> 中读取并设置 MySQL 的管理员密码。</li></ol><h4 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a>security_opt</h4><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">security_opt:</span></span><br><span class="line"><span class="attr">    - label:</span><span class="attr">user:USER</span></span><br><span class="line"><span class="attr">    - label:</span><span class="attr">role:ROLE</span></span><br></pre></td></tr></table></figure><h4 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a>stop_signal</h4><p>设置另一个信号来停止容器。在默认情况下使用的是 <code>SIGTERM</code> 停止容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stop_signal:</span> <span class="string">SIGUSR1</span> <span class="comment"># 缺省值</span></span><br></pre></td></tr></table></figure><h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h4><p>配置容器内核参数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="string">net.core.somaxconn:</span> <span class="number">1024</span></span><br><span class="line">  <span class="string">net.ipv4.tcp_syncookies:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># other grammar</span></span><br><span class="line"><span class="attr">sysctls:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">net.core.somaxconn=1024</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">net.ipv4.tcp_syncookies=0</span></span><br></pre></td></tr></table></figure><h4 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h4><p>指定容器的 <code>ulimits</code> 限制值。</p><p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line"><span class="attr">  nproc:</span> <span class="number">65535</span></span><br><span class="line"><span class="attr">  nofile:</span></span><br><span class="line"><span class="attr">    soft:</span> <span class="number">20000</span></span><br><span class="line"><span class="attr">    hard:</span> <span class="number">40000</span></span><br></pre></td></tr></table></figure><h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h4><p>数据卷所挂载路径设置。可以设置宿主机路径 （<code>HOST:CONTAINER</code>） 或加上访问模式 （<code>HOST:CONTAINER:ro</code>）。</p><p>该指令中路径支持相对路径。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"> <span class="comment"># 只是指定一个路径，Docker 会自动在创建一个数据卷（这个路径是容器内部的）。</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"> <span class="comment"># 使用绝对路径挂载数据卷</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">/opt/data:/var/lib/mysql</span></span><br><span class="line"> <span class="comment"># 以 Compose 配置文件为中心的相对路径作为数据卷挂载到容器。</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">cache/:/tmp/cache</span></span><br><span class="line"> <span class="comment"># 使用用户的相对路径（~/ 表示的目录是 /home/&lt;用户目录&gt;/ 或者 /root/）。</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">~/configs:/etc/configs/:ro</span></span><br><span class="line"> <span class="comment"># 已经存在的命名的数据卷。</span></span><br><span class="line"><span class="attr"> - datavolume:</span><span class="string">/var/lib/mysql</span></span><br></pre></td></tr></table></figure><p>例如编排一个 pqsql:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line"><span class="attr">  pq:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">postgres:9.5</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      POSTGRES_PASSWORD:</span> <span class="string">postgres</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"5432:5432"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - db_data:</span><span class="string">/var/lib/postgresql</span></span><br><span class="line"><span class="attr">      - db_log:</span><span class="string">/var/log/postgresql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  db_data:</span></span><br><span class="line"><span class="attr">  db_log:</span></span><br></pre></td></tr></table></figure><p>举个例子，自动创建一个数据卷 <code>pq_db_data</code>，目录在 <code>/var/lib/docker/volumes/</code> 下。</p><p>将 容器 <code>pq</code> 的目录 <code>/var/lib/postgresql</code> 挂载到数据卷 <code>pq_db_data</code>。</p><h4 id="volumes-from"><a href="#volumes-from" class="headerlink" title="volumes_from"></a>volumes_from</h4><p>从其它容器或者服务挂载数据卷，可选的参数是 :ro或者 :rw，前者表示容器只读，后者表示容器对数据卷是可读可写的。默认情况下是可读可写的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes_from:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">service_name</span></span><br><span class="line"><span class="attr">  - service_name:</span><span class="string">ro</span></span><br><span class="line"><span class="attr">  - container:</span><span class="string">container_name</span></span><br><span class="line"><span class="attr">  - container:</span><span class="attr">container_name:rw</span></span><br></pre></td></tr></table></figure><h4 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h4><p>指定服务容器启动后执行的入口文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entrypoint:</span> <span class="string">/code/entrypoint.sh</span></span><br></pre></td></tr></table></figure><h4 id="privileged"><a href="#privileged" class="headerlink" title="privileged"></a>privileged</h4><p>允许容器中运行一些特权命令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h4><p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><blockquote><p>在 Swarm 中失效，Swarm Stacks use the <code>restart_policy:</code> under the <code>deploy:</code></p></blockquote><h4 id="working-dir"><a href="#working-dir" class="headerlink" title="working_dir"></a>working_dir</h4><p>指定容器中工作目录。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">working_dir</span></span><br></pre></td></tr></table></figure><h4 id="user"><a href="#user" class="headerlink" title="user"></a>user</h4><p>指定容器中运行应用的用户名。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><h4 id="基本的使用格式"><a href="#基本的使用格式" class="headerlink" title="基本的使用格式"></a>基本的使用格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure><p><code>options</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-f, --file FILE           指定启动模版文件(一个非docker-compose.yml命名的yaml文件,默认为docker-compose.yml)</span><br><span class="line">-p, --project-name NAME   指定一个替代项目名称 (默认是directory名)</span><br><span class="line">-d 以daemon的方式启动容器</span><br><span class="line">--x-networking            (EXPERIMENTAL) 使用新的网络功能</span><br><span class="line">--x-network-driver DRIVER (EXPERIMENTAL) 指定网络驱动程序，桥 (default: <span class="string">"bridge"</span>).</span><br><span class="line">--verbose：输出详细信息</span><br><span class="line">--version 打印版本并退出。</span><br></pre></td></tr></table></figure><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="build-1"><a href="#build-1" class="headerlink" title="build"></a>build</h5><p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p><p>构建（重新构建）项目中的服务容器。</p><p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p><p>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</p><p>选项包括：</p><ul><li><code>--force-rm</code> 删除构建过程中的临时容器。</li><li><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</li><li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li></ul><h5 id="config"><a href="#config" class="headerlink" title="config"></a>config</h5><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p><h5 id="down"><a href="#down" class="headerlink" title="down"></a>down</h5><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络。</p><h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h5><p>进入指定的容器。</p><h5 id="help"><a href="#help" class="headerlink" title="help"></a>help</h5><p>获取命令的帮助信息。</p><h5 id="images"><a href="#images" class="headerlink" title="images"></a>images</h5><p>列出这个 Compose 项目中包含的镜像。</p><h5 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h5><p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p><p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p><p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">kill</span> -s SIGINT</span><br></pre></td></tr></table></figure><h5 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h5><p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p><p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p><p>该命令在调试问题的时候十分有用。</p><h5 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h5><p>暂停一个或多个容器。</p><h5 id="port"><a href="#port" class="headerlink" title="port"></a>port</h5><p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p><p>打印某个容器端口所映射的公共端口。</p><p>选项：</p><ul><li><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</li><li><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</li></ul><h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p><p>列出项目中目前的所有容器。</p><p>选项：</p><ul><li><code>-q</code> 只打印容器的 ID 信息。</li></ul><h5 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h5><p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p><p>拉取服务依赖的镜像。</p><p>选项：</p><ul><li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li></ul><h5 id="push"><a href="#push" class="headerlink" title="push"></a>push</h5><p>推送服务依赖的镜像到 Docker 镜像仓库。</p><h5 id="restart-1"><a href="#restart-1" class="headerlink" title="restart"></a>restart</h5><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p><p>重启项目中的服务。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li></ul><h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h5><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p><p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p><p>选项：</p><ul><li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li><li><code>-v</code> 删除容器所挂载的数据卷。</li></ul><h5 id="run"><a href="#run" class="headerlink" title="run"></a>run</h5><p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p><p>在指定服务上执行一个命令。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run ubuntu ping docker.com</span><br></pre></td></tr></table></figure><p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p><p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p><p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p><p>两个不同点：</p><ul><li>给定命令将会覆盖原有的自动运行命令；</li><li>不会自动创建端口，以避免冲突。</li></ul><p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose run --no-deps web python manage.py shell</span><br></pre></td></tr></table></figure><p>将不会启动 web 容器所关联的其它容器。</p><p>选项：</p><ul><li><code>-d</code> 后台运行容器。</li><li><code>--name NAME</code> 为容器指定一个名字。</li><li><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</li><li><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</li><li><code>-u, --user=&quot;&quot;</code> 指定运行容器的用户名或者 uid。</li><li><code>--no-deps</code> 不自动启动关联的服务容器。</li><li><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</li><li><code>-p, --publish=[]</code> 映射容器端口到本地主机。</li><li><code>--service-ports</code> 配置服务端口并映射到本地主机。</li><li><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</li></ul><h5 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h5><p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p><p>设置指定服务运行的容器个数。</p><p>通过 <code>service=num</code> 的参数来设置数量。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose scale web=3 db=2</span><br></pre></td></tr></table></figure><p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p><p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h5 id="start"><a href="#start" class="headerlink" title="start"></a>start</h5><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p><p>启动已经存在的服务容器。</p><h5 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h5><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p><p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h5 id="top"><a href="#top" class="headerlink" title="top"></a>top</h5><p>查看各个服务容器内运行的进程。</p><h5 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a>unpause</h5><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p><p>恢复处于暂停状态中的服务。</p><h5 id="up"><a href="#up" class="headerlink" title="up"></a>up</h5><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p><p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p><p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p><p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p><p>选项：</p><ul><li><code>-d</code> 在后台运行服务容器。</li><li><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</li><li><code>--no-deps</code> 不启动服务所链接的容器。</li><li><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</li><li><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</li><li><code>--no-build</code> 不自动构建缺失的服务镜像。</li><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h5 id="version"><a href="#version" class="headerlink" title="version"></a>version</h5><p>格式为 <code>docker-compose version</code>。</p><p>打印版本信息。</p><h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><p>实战 <code>WordPress</code> 项目：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">   db:</span></span><br><span class="line"><span class="attr">     image:</span> <span class="attr">mysql:5.7</span></span><br><span class="line"><span class="attr">     volumes:</span></span><br><span class="line"><span class="attr">       - db_data:</span><span class="string">/var/lib/mysql</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">     environment:</span></span><br><span class="line"><span class="attr">       MYSQL_ROOT_PASSWORD:</span> <span class="string">somewordpress</span></span><br><span class="line"><span class="attr">       MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line"></span><br><span class="line"><span class="attr">   wordpress:</span></span><br><span class="line"><span class="attr">     depends_on:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">db</span></span><br><span class="line"><span class="attr">     image:</span> <span class="attr">wordpress:latest</span></span><br><span class="line"><span class="attr">     ports:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"8000:80"</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">     environment:</span></span><br><span class="line"><span class="attr">       WORDPRESS_DB_HOST:</span> <span class="attr">db:3306</span></span><br><span class="line"><span class="attr">       WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">    db_data:</span></span><br></pre></td></tr></table></figure><h2 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h2><p>docker技术是基于Linux内核的<code>cgroup</code>技术实现的，那么问题来了，在非Linux平台上是否就不能使用docker技术了呢？答案是可以的，不过显然需要借助虚拟机去模拟出Linux环境来。</p><p>Docker Machine 就是docker公司官方提出的，用于在各种平台上快速创建具有docker服务的虚拟机的技术，甚至可以通过指定driver来定制虚拟机的实现原理（一般是virtualbox）。</p><p>Docker Machine 是 Docker 官方编排（Orchestration）项目之一，负责在多种平台上快速安装 Docker 环境。</p><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><p>查询版本信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine -v</span><br></pre></td></tr></table></figure><p>在 Linux 64 位系统上直接下载对应的二进制包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-machine</span><br><span class="line">$ sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-machine</span><br></pre></td></tr></table></figure><p>完成后，查看版本信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine -v</span><br><span class="line">docker-machine version 0.13.0, build 9ba6da9</span><br></pre></td></tr></table></figure><h3 id="创建本地主机驱动"><a href="#创建本地主机驱动" class="headerlink" title="创建本地主机驱动"></a>创建本地主机驱动</h3><ol><li><p>创建一个 <code>virtualbox</code> 类型的驱动，名为 <code>test1</code>，可以加上参数配置分配的硬件的信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create -d virtualbox test1</span><br><span class="line">Running pre-create checks...</span><br><span class="line">Error with pre-create check: <span class="string">"VBoxManage not found. Make sure VirtualBox is installed and VBoxManage is in the path"</span></span><br></pre></td></tr></table></figure><p>出现了错误，需要安装VirtualBox环境</p><ul><li><p>配置VirtualBox源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$  vim /etc/yum.repos.d/virtualbox.repo    </span><br><span class="line">[virtualbox]</span><br><span class="line">name=Oracle Linux / RHEL / CentOS-<span class="variable">$releasever</span> / <span class="variable">$basearch</span> - VirtualBox</span><br><span class="line">baseurl=http://download.virtualbox.org/virtualbox/rpm/el/<span class="variable">$releasever</span>/<span class="variable">$basearch</span></span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://www.virtualbox.org/download/oracle_vbox.asc</span><br></pre></td></tr></table></figure></li><li><p>安装VirtualBox</p><ul><li><p>CentOS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 先搜索</span></span><br><span class="line"><span class="comment"># 2. 安装版本</span></span><br><span class="line"><span class="comment"># 3. 重新加载配置</span></span><br><span class="line">$ yum search VirtualBox </span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">======================================= N/S matched: VirtualBox ========================================</span><br><span class="line">VirtualBox-4.3.x86_64 : Oracle VM VirtualBox</span><br><span class="line">VirtualBox-5.0.x86_64 : Oracle VM VirtualBox</span><br><span class="line">VirtualBox-5.1.x86_64 : Oracle VM VirtualBox</span><br><span class="line">VirtualBox-5.2.x86_64 : Oracle VM VirtualBox</span><br><span class="line"></span><br><span class="line">  Name and summary matches only, use <span class="string">"search all"</span> <span class="keyword">for</span> everything.</span><br><span class="line">$ yum install -y VirtualBox-5.1</span><br><span class="line">$ /sbin/vboxconfig    </span><br><span class="line"><span class="comment"># 中间出了点问题，说是少了</span></span><br><span class="line"><span class="comment"># This system is not currently set up to build kernel modules (system extensions).</span></span><br><span class="line"><span class="comment">#Running the following commands should set the system up correctly:</span></span><br><span class="line"><span class="comment">#   yum install kernel-devel-3.10.0-693.2.2.el7.x86_64</span></span><br><span class="line">$ yum install kernel-devel-3.10.0-693.2.2.el7.x86_64</span><br><span class="line"><span class="comment"># 重新再次加载</span></span><br><span class="line">$ /sbin/vboxconfig  </span><br><span class="line"><span class="comment"># 启动成功，心累</span></span><br></pre></td></tr></table></figure><p>然后就可以创建了虚拟驱动了。</p></li><li><p>Ubuntu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手上暂时没有 Ubuntu 系统没有测试，网上都是这么说的，记录下，没有验证，</span></span><br><span class="line">$ apt-get install virtualbox</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>还有一种问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"This computer doesn't have VT-X/AMD-v enabled. Enabling it in the BIOS is mandatory"</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/docker/machine/issues/4271" rel="external nofollow noopener noreferrer" target="_blank">issues/4271</a>额，我之前是一直远程在阿里云上的服务器做的， 由于一直很讨厌 WINDOW 的命令模式，甩锅啦，现在好了，这个问题要修改 BIOS ，只好又回到 WINDOW 平台上做</p></li><li><p>登陆到主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls </span><br><span class="line">NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">default   *        virtualbox   Running   tcp://192.168.99.100:2376           v17.12.0-ce</span><br><span class="line">test1     -        virtualbox   Running   tcp://192.168.99.101:2376           v18.04.0-ce</span><br><span class="line"></span><br><span class="line">$ docker-machine ssh test1</span><br><span class="line"><span class="comment"># 后面就可以操作 test1 了</span></span><br></pre></td></tr></table></figure></li></ol><p>补充，通过 <code>-d</code> 选项可以选择支持的驱动类型。</p><ul><li>amazonec2</li><li>azure</li><li>digitalocean</li><li>exoscale</li><li>generic</li><li>google</li><li>hyperv</li><li>none</li><li>openstack</li><li>rackspace</li><li>softlayer</li><li>virtualbox</li><li>vmwarevcloudair</li><li>vmwarefusion</li><li>vmwarevsphere</li></ul><h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><ul><li><code>active</code> 查看活跃的 Docker 主机</li><li><code>config</code> 输出连接的配置信息</li><li><code>create</code> 创建一个 Docker 主机</li><li><code>env</code> 显示连接到某个主机需要的环境变量</li><li><code>inspect</code> 输出主机更多信息</li><li><code>ip</code> 获取主机地址</li><li><code>kill</code> 停止某个主机</li><li><code>ls</code> 列出所有管理的主机</li><li><code>provision</code> 重新设置一个已存在的主机</li><li><code>regenerate-certs</code> 为某个主机重新生成 TLS 认证信息</li><li><code>restart</code> 重启主机</li><li><code>rm</code> 删除某台主机</li><li><code>ssh</code> SSH 到主机上执行命令</li><li><code>scp</code> 在主机之间复制文件</li><li><code>mount</code> 挂载主机目录到本地</li><li><code>start</code> 启动一个主机</li><li><code>status</code> 查看主机状态</li><li><code>stop</code> 停止一个主机</li><li><code>upgrade</code> 更新主机 Docker 版本为最新</li><li><code>url</code> 获取主机的 URL</li><li><code>version</code> 输出 docker-machine 版本信息</li><li><code>help</code> 输出帮助信息</li></ul><h2 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h2><p>Docker 1.12 <a href="https://docs.docker.com/engine/swarm/" rel="external nofollow noopener noreferrer" target="_blank">Swarm mode</a> 已经内嵌入 Docker 引擎，成为了 docker 子命令 <code>docker swarm</code>。</p><p><code>Swarm mode</code> 内置 kv 存储功能，提供了众多的新特性，比如：具有容错能力的去中心化设计、内置服务发现、负载均衡、路由网格、动态伸缩、滚动更新、安全传输等。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p>运行 Docker 的主机可以主动初始化一个 <code>Swarm</code> 集群或者加入一个已存在的 <code>Swarm</code> 集群，这样这个运行 Docker 的主机就成为一个 <code>Swarm</code> 集群的节点 (<code>node</code>) 。</p><p>节点分为管理 (<code>manager</code>) 节点和工作 (<code>worker</code>) 节点。</p><p>管理节点用于 <code>Swarm</code> 集群的管理，<code>docker swarm</code> 命令基本只能在管理节点执行（节点退出集群命令 <code>docker swarm leave</code> 可以在工作节点执行）。一个 <code>Swarm</code> 集群可以有多个管理节点，但只有一个管理节点可以成为 <code>leader</code>，<code>leader</code> 通过 <code>raft</code> 协议实现。</p><p>工作节点是任务执行节点，管理节点将服务 (<code>service</code>) 下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点。</p><p>来自 Docker 官网的这张图片形象的展示了集群中管理节点与工作节点的关系。</p><p><img src="https://docs.docker.com/engine/swarm/images/swarm-diagram.png" alt="img"></p><h4 id="服务和任务"><a href="#服务和任务" class="headerlink" title="服务和任务"></a>服务和任务</h4><p>任务 （<code>Task</code>）是 <code>Swarm</code> 中的最小的调度单位，目前来说就是一个单一的容器。</p><p>服务 （<code>Services</code>） 是指一组任务的集合，服务定义了任务的属性。服务有两种模式：</p><ul><li><code>replicated services</code> 按照一定规则在各个工作节点上运行指定个数的任务。</li><li><code>global services</code> 每个工作节点上运行一个任务</li></ul><p>两种模式通过 <code>docker service create</code> 的 <code>--mode</code> 参数指定。</p><p>来自 Docker 官网的这张图片形象的展示了容器、任务、服务的关系。</p><p><img src="https://docs.docker.com/engine/swarm/images/services-diagram.png" alt="img"></p><h3 id="创建-Swarm-集群"><a href="#创建-Swarm-集群" class="headerlink" title="创建 Swarm 集群"></a>创建 Swarm 集群</h3><p>前面我们了解到 Swarm 集群是由 <code>manager</code> 和 <code>worker</code> 组成的。</p><h4 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h4><p>初始化一个 manager，主机有多个网卡，拥有多个 IP，必须使用 <code>--advertise-addr</code> 指定 IP。：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create -d virtualbox manager</span><br><span class="line"></span><br><span class="line">docker@manager:~$ docker-machine ssh manager</span><br><span class="line">docker@manager:~$ ip addr</span><br><span class="line"><span class="comment"># 主机有多个网卡，拥有多个 IP，必须使用 --advertise-addr 指定 IP。</span></span><br><span class="line">docker@manager:~$ docker swarm init --advertise-addr 192.168.99.102</span><br><span class="line">Swarm initialized: current node (wwyq0ym88dvuhxkljr4963kei) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following <span class="built_in">command</span>:</span><br><span class="line"></span><br><span class="line">    docker swarm join --token SWMTKN-1-3js3ppvjj191r9qx92uiva4l64z8xgy6sno69et5y9ri7a8es5-695418k4uks90r9j9bgwag2k3 192.168.99.102:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run <span class="string">'docker swarm join-token manager'</span> and follow the instructions.</span><br></pre></td></tr></table></figure><h4 id="工作节点"><a href="#工作节点" class="headerlink" title="工作节点"></a>工作节点</h4><ol><li><p>新增加一个工作节点 <code>worker1</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create -d virtualbox worker1</span><br><span class="line">$ docker-machine ssh worker1</span><br><span class="line"></span><br><span class="line">docker@worker1:~$ docker swarm join --token SWMTKN-1-3js3ppvjj191r9qx92uiva4l64z8xgy6sno69et5y9ri7a8es5-695418k4uks90r9j</span><br><span class="line">9bgwag2k3 192.168.99.102:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure></li><li><p>然后按照上面的步骤，新增一个节点 <code>worker2</code>。</p></li><li><p>进入 <code>manager</code> 节点 ，查看集群状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker@manager:~$ docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">wwyq0ym88dvuhxkljr4963kei *   manager             Ready               Active              Leader              18.04.0-ce</span><br><span class="line">dncrx0o8lbq0a5v8lcdwt2onl     worker1             Ready               Active                                  18.04.0-ce</span><br><span class="line">d9d9pjhwh86lz42klh41ud8ss     worker2             Ready               Active</span><br></pre></td></tr></table></figure></li></ol><h3 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h3><p>我们使用 <code>docker service</code> 命令来管理 <code>Swarm</code> 集群中的服务，该命令只能在管理（manager）节点运行。</p><h4 id="新建服务"><a href="#新建服务" class="headerlink" title="新建服务"></a>新建服务</h4><p>在上面我们创建的 Swarm 集群中的 <code>manager</code> 节点中 运行一个 nginx 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create --replicas 3 -p 80:80 --name nginx nginx:1.13.7-alpine</span><br><span class="line">mqisdpsereiv0x3whj74lpbxi</span><br><span class="line">overall progress: 3 out of 3 tasks</span><br><span class="line">1/3: running   [==================================================&gt;]</span><br><span class="line">2/3: running   [==================================================&gt;]</span><br><span class="line">3/3: running   [==================================================&gt;]</span><br><span class="line">verify: Service converged</span><br></pre></td></tr></table></figure><h4 id="查询服务"><a href="#查询服务" class="headerlink" title="查询服务"></a>查询服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询服务</span></span><br><span class="line">docker@manager:~$ docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                 PORTS</span><br><span class="line">mqisdpsereiv        nginx               replicated          3/3                 nginx:1.13.7-alpine   *:80-&gt;80/tcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询进程</span></span><br><span class="line">docker@manager:~$ docker service ps nginx</span><br><span class="line">ID                  NAME                IMAGE                 NODE                DESIRED STATE       CURRENT STATE           ERROR               PORTS</span><br><span class="line">wyvxj6nyp435        nginx.1             nginx:1.13.7-alpine   manager             Running             Running 2 minutes ago</span><br><span class="line">o9qb0pmi1epu        nginx.2             nginx:1.13.7-alpine   worker1             Running             Running 3 minutes ago</span><br><span class="line">45uxv7c6s2b0        nginx.3             nginx:1.13.7-alpine   worker2             Running             Running 3 minutes ago</span><br></pre></td></tr></table></figure><p>我的集群三个节点的 IP 分别是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">manager   -        virtualbox   Running   tcp://192.168.99.102:2376           v18.04.0-ce</span><br><span class="line">worker1   -        virtualbox   Running   tcp://192.168.99.103:2376           v18.04.0-ce</span><br><span class="line">worker2   -        virtualbox   Running   tcp://192.168.99.104:2376           v18.04.0-ce</span><br></pre></td></tr></table></figure><p>分别访问这几个节点的 ip 都能访问到熟悉 nginx 欢迎页。</p><p>查询日志 <code>docker service logs &lt;service&gt;</code></p><h4 id="删除服务"><a href="#删除服务" class="headerlink" title="删除服务"></a>删除服务</h4><p>使用 <code>docker service rm</code> 来从 <code>Swarm</code> 集群移除某个服务。</p><h3 id="使用-compose-文件部署"><a href="#使用-compose-文件部署" class="headerlink" title="使用 compose 文件部署"></a>使用 compose 文件部署</h3><p><strong>需要注意的 swarm 的compose 多出一些模板指令，而且以前 <code>docker-compose</code> 中的一些指令将失效。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>部署服务使用 <code>docker stack deploy</code>，其中 <code>-c</code> 参数指定 compose 文件名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack deploy -c docker-compose-swarm.yml myweb-name</span><br></pre></td></tr></table></figure><p>查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack ls</span><br><span class="line">NAME                SERVICES</span><br><span class="line">wordpress           2</span><br></pre></td></tr></table></figure><p>移除服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack down</span><br></pre></td></tr></table></figure><p><a href="https://github.com/kaimz/learning-code/tree/master/springboot-docker?1523630460079" rel="external nofollow noopener noreferrer" target="_blank">服务编排和 Swarm集群的例子</a></p><p>我们以在 <code>Swarm</code> 集群中部署 <code>WordPress</code> 为例进行说明。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  wordpress:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">overlay</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      WORDPRESS_DB_HOST:</span> <span class="attr">db:3306</span></span><br><span class="line"><span class="attr">      WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">      WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      mode:</span> <span class="string">replicated</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  db:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">overlay</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - db-data:</span><span class="string">/var/lib/mysql</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      MYSQL_ROOT_PASSWORD:</span> <span class="string">somewordpress</span></span><br><span class="line"><span class="attr">      MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">      MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">      MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      placement:</span></span><br><span class="line"><span class="attr">        constraints:</span> <span class="string">[node.role</span> <span class="string">==</span> <span class="string">manager]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  visualizer:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">dockersamples/visualizer:stable</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8080:8080"</span></span><br><span class="line"><span class="attr">    stop_grace_period:</span> <span class="number">1</span><span class="string">m30s</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/var/run/docker.sock:/var/run/docker.sock"</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      placement:</span></span><br><span class="line"><span class="attr">        constraints:</span> <span class="string">[node.role</span> <span class="string">==</span> <span class="string">manager]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  db-data:</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  overlay:</span></span><br></pre></td></tr></table></figure><p>在 <code>Swarm</code> 集群管理节点新建该文件，其中的 <code>visualizer</code> 服务提供一个可视化页面，我们可以从浏览器中很直观的查看集群中各个服务的运行节点。</p><h2 id="远程-API-架构"><a href="#远程-API-架构" class="headerlink" title="远程 API 架构"></a>远程 API 架构</h2><h3 id="了解-1"><a href="#了解-1" class="headerlink" title="了解"></a>了解</h3><h4 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h4><p>Docker的基础服务，比如容器的创建、查看、停止、镜像的管理，其实都是由docker的守护进程(daemon)来实现的。</p><p>每次执行的Docker指令其实都是通过向daemon发送请求来实现的。</p><p>daemon的运作（通信模式）主要有两种，一种是通过unix套接字（默认，但只能在本地访问到，比较安全），一种是通过监听tcp协议地址和端口来实现（这个可以实现在远程调用到docker服务）。</p><h4 id="远程-API"><a href="#远程-API" class="headerlink" title="远程 API"></a>远程 API</h4><p>除了通过远程tcp协议访问远程主机上的docker服务外，docker还提供了一套基于HTTP的API，可以使用curl来实现操作远程主机上的docker服务，这为开发基于WEB的docker服务提供了便利。</p><h3 id="开启远程-API"><a href="#开启远程-API" class="headerlink" title="开启远程 API"></a>开启远程 API</h3><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>1.12版本后, 用户可以自行创建配置文件 <code>/etc/docker/daemon.json</code>，该文件不区分系统，是通用的，推荐使用。具体参考：<a href="https://docs.docker.com/engine/admin/" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>。不知道版本的可以通过 <code>$ dockerd version</code> 查看。</p><p>方式一： 首先，你需要创建 <code>/etc/docker/daemon.json</code> 文件，文件内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"hosts"</span>: [</span><br><span class="line">    <span class="string">"tcp://0.0.0.0:2375"</span>,</span><br><span class="line">    <span class="string">"unix:///var/run/docker.sock"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启的是 <code>2375</code> 端口。</p><p>然后重启生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure><p>方式二 ： 当然也可以更改启动命令的方式 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 系统</span></span><br><span class="line">$ sudo vim /lib/systemd/system/docker.service</span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">$ sudo vim /usr/lib/systemd/system/docker.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改下面的启动命令</span></span><br><span class="line">ExecStart=/usr/bin/dockerd  -H tcp://0.0.0.0:2375  -H unix:///var/run/docker.sock</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure><p>使用的时候只需要在客户端的主机上加上环境变量 <code>DOCKER_HOST=tcp://xxx.xxx.xx.xx/2375</code>，就可以在主机上使用远程的 Docker API。</p><h4 id="Docker-Toolbox"><a href="#Docker-Toolbox" class="headerlink" title="Docker Toolbox"></a>Docker Toolbox</h4><ol><li><p>在 window 或者 mac 上面使用 <code>Docker-toolbox</code>，则就比较简单了，,打开 <code>docker QuickStart Terminal</code> 终端，输入命令 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line"></span><br><span class="line">NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">default   -        virtualbox   Running   tcp://192.168.99.100:2376           v17.10.0-ce</span><br></pre></td></tr></table></figure><p>查询到 URL，根据上面的结果</p><p>我使用的是 WONDOW 电脑的主机上加上环境变量 <code>DOCKER_HOST=tcp://192.168.99.100:2376</code>；</p><p>当然也可以使用 <code>VirtualBox</code> 的端口映射到 本地的 2375端口也行，docker 默认的 host 是 <code>127.0.0.1:2376</code>，这样环境变量也不用配置。</p></li><li><p>我使用的是 WIN10 ，后面也是这个开发环境，打开 <code>PowerShell</code> 执行命令 docker version 命令发现一个问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Get http://192.168.99.100:2376/v1.33/containers/json: malformed HTTP response <span class="string">"\x15\x03\x01\x00\x02\x02"</span>.</span><br><span class="line">* Are you trying to connect to a TLS-enabled daemon without TLS?</span><br></pre></td></tr></table></figure><p>发现它需要 TLS ，</p><p>设置环境变量 <code>DOCKER_TLS_VERIFY=1</code></p></li><li><p>然后再次执行 docker version 命令，发现又出现 问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The server probably has client authentication (--tlsverify) enabled. Please check your TLS client certification settings: Get https://192.168.99.100:2376/v1.35/version: remote error: tls: bad certificate</span><br></pre></td></tr></table></figure><p>没指定 证书 <code>cret</code>。 证书的路径在当前用户的 <code>/.docker/certs</code>下：</p><p>设置环境变量 <code>DOCKER_CERT_PATH=C:/Users/KronChan/.docker/machine/certs</code></p></li></ol><p>配置好，我们就能直接能在自己的主机中 使用 虚拟机中的 Docker API。</p><h2 id="一些其他的问题解决"><a href="#一些其他的问题解决" class="headerlink" title="一些其他的问题解决"></a>一些其他的问题解决</h2><h3 id="更改Docker-默认镜像路径"><a href="#更改Docker-默认镜像路径" class="headerlink" title="更改Docker 默认镜像路径"></a>更改Docker 默认镜像路径</h3><p>一般的我们系统盘不会给很大的空间，然而 Docker 镜像占用的空间一般都是非常大的，所以我们需要将镜像和容器挂在到其他数据盘下。</p><p>docker 默认的数据目录都在<code>/var/lib/docker/</code> 下，我们只要将这个目录挂载到其他数据盘目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前提关闭 docker </span></span><br><span class="line"><span class="comment"># 1. 数据盘中新建一个目录，用于存放docker数据</span></span><br><span class="line"><span class="comment"># 2. 将原数据目录移动到新建的目录中</span></span><br><span class="line"><span class="comment"># 3. 创建软链接，将数据盘中的docker数据目录挂到/var/lib/docker/</span></span><br><span class="line"><span class="comment"># 4. 重启 docker 查询 Docker 信息</span></span><br><span class="line"><span class="comment"># 查询到结果 ‘Docker Root Dir: /media/kronchan/文件/kronchan/tools/docker’</span></span><br></pre></td></tr></table></figure><h3 id="WARNING-No-memory-limit-support"><a href="#WARNING-No-memory-limit-support" class="headerlink" title="WARNING: No memory limit support"></a>WARNING: No memory limit support</h3><p>查询 <code>sudo docker info</code>的时候发现警告信息：<code>WARNING: No memory limit support</code>。</p><p>解决方案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/default/grub</span><br><span class="line"><span class="comment"># 加入 GRUB_CMDLINE_LINUX="cgroup_enable=memory swapaccount=1"</span></span><br><span class="line"><span class="comment"># 更新 grub</span></span><br><span class="line">$ sudo grub-update</span><br><span class="line">sudo: grub-update：找不到命令</span><br><span class="line">$ sudo update-grub</span><br><span class="line">Generating grub configuration file ...</span><br><span class="line">Found theme: /boot/grub/themes/deepin/theme.txt</span><br><span class="line">Found background image: /boot/grub/themes/deepin/background.png</span><br><span class="line">Found linux image: /boot/vmlinuz-4.9.0-deepin13-amd64</span><br><span class="line">Found initrd image: /boot/initrd.img-4.9.0-deepin13-amd64</span><br><span class="line">Found deepin image: /boot/deepin/vmlinuz-4.13.4</span><br><span class="line">Found initrd image: /boot/deepin/initrd.img-4.13.4</span><br><span class="line">Adding boot menu entry <span class="keyword">for</span> EFI firmware configuration</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 重启系统，然后检查查看问题是否存在</span></span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://docs.docker.com/" rel="external nofollow noopener noreferrer" target="_blank">Docker Documentation</a></li><li><a href="https://legacy.gitbook.com/book/yeasy/docker_practice/details" rel="external nofollow noopener noreferrer" target="_blank">Docker — 从入门到实践</a></li><li><a href="http://www.widuu.com/docker/index.html" rel="external nofollow noopener noreferrer" target="_blank">Docker 中文指南</a></li><li><a href="https://deepzz.com/post/dockerd-and-docker-remote-api.html" rel="external nofollow noopener noreferrer" target="_blank">远程连接docker daemon，Docker Remote API</a></li><li><a href="https://yq.aliyun.com/articles/91396" rel="external nofollow noopener noreferrer" target="_blank">优雅地实现安全的容器编排 - Docker Secrets</a></li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">------本文结束 🖐 感谢阅读------</div></div></div><div></div><div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong> Kai Zhang</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://blog.wuwii.com/docker-note.html" title="学习 Docker 笔记">http://blog.wuwii.com/docker-note.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Docker/" rel="tag"><i class="fa fa-tag"></i> Docker</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/docker-jenkins.html" rel="next" title="使用 Docker 安装 Jenkins"><i class="fa fa-chevron-left"></i> 使用 Docker 安装 Jenkins</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/springboot-security.html" rel="prev" title="学习Spring Boot：（二十八）Spring Security 权限认证">学习Spring Boot：（二十八）Spring Security 权限认证 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"><script>window._bd_share_config={common:{bdText:"",bdMini:"1",bdMiniList:!1,bdPic:""},image:{viewList:["tsina","douban","sqq","qzone","weixin","twi","fbook"],viewText:"分享到：",viewSize:"16"},slide:{bdImg:"5",bdPos:"left",bdTop:"100"}}</script><script>with(document)(0)[(getElementsByTagName("head")[0]||body).appendChild(createElement("script")).src="/static/api/js/share.js?v=89860593.js?cdnversion="+~(-new Date/36e5)]</script></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="https://oss.wuwii.com/image/head/%E6%97%A0%E9%99%90.jpg" alt="Kai Zhang"><p class="site-author-name" itemprop="name">Kai Zhang</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">82</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">29</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS </a><a title="收藏到书签，偶尔High一下^_^" rel="alternate external nofollow" class="mw-harlem_shake_slow wobble shake" href="javascript:go()"><i class="fa fa-music"></i> 听音乐</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/kaimz" target="_blank" title="GitHub" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="mailto:im.zhangk@qq.com" target="_blank" title="Email" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-envelope-o"></i> Email </a></span><span class="links-of-author-item"><a href="http://wpa.qq.com/msgrd?v=3&uin=1075199251&site=qq&menu=yes" target="_blank" title="QQ" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-qq"></i> QQ</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-globe"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://weispring.github.io/" title="悦夏" target="_blank" rel="external nofollow noopener noreferrer">悦夏</a></li><li class="links-of-blogroll-item"><a href="http://sdll.club" title="闪电拉拉" target="_blank" rel="external nofollow noopener noreferrer">闪电拉拉</a></li><li class="links-of-blogroll-item"><a href="https://www.draw.io/" title="draw.io" target="_blank" rel="external nofollow noopener noreferrer">draw.io</a></li><li class="links-of-blogroll-item"><a href="https://www.processon.com/" title="processon" target="_blank" rel="external nofollow noopener noreferrer">processon</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要使用-Docker"><span class="nav-number">1.</span> <span class="nav-text">为什么要使用 Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-Docker"><span class="nav-number">1.1.</span> <span class="nav-text">什么是 Docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要用-Docker"><span class="nav-number">1.2.</span> <span class="nav-text">为什么要用 Docker</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#了解-Docker-的基本概念"><span class="nav-number">2.</span> <span class="nav-text">了解 Docker 的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#镜像"><span class="nav-number">2.1.</span> <span class="nav-text">镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分层存储"><span class="nav-number">2.2.</span> <span class="nav-text">分层存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器"><span class="nav-number">2.3.</span> <span class="nav-text">容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本使用"><span class="nav-number">3.</span> <span class="nav-text">基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装"><span class="nav-number">3.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#镜像加速"><span class="nav-number">3.2.</span> <span class="nav-text">镜像加速</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#镜像-1"><span class="nav-number">3.3.</span> <span class="nav-text">镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#查找镜像语法"><span class="nav-number">3.3.1.</span> <span class="nav-text">查找镜像语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取镜像"><span class="nav-number">3.3.2.</span> <span class="nav-text">获取镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列出镜像"><span class="nav-number">3.3.3.</span> <span class="nav-text">列出镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除镜像"><span class="nav-number">3.3.4.</span> <span class="nav-text">删除镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tag"><span class="nav-number">3.3.5.</span> <span class="nav-text">tag</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-Dockerfile-定制镜像"><span class="nav-number">3.3.6.</span> <span class="nav-text">使用 Dockerfile 定制镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FROM"><span class="nav-number">3.3.6.1.</span> <span class="nav-text">FROM</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RUN"><span class="nav-number">3.3.6.2.</span> <span class="nav-text">RUN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#COPY"><span class="nav-number">3.3.6.3.</span> <span class="nav-text">COPY</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ADD"><span class="nav-number">3.3.6.4.</span> <span class="nav-text">ADD</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CMD"><span class="nav-number">3.3.6.5.</span> <span class="nav-text">CMD</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ENTRYPOINT"><span class="nav-number">3.3.6.6.</span> <span class="nav-text">ENTRYPOINT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ENV"><span class="nav-number">3.3.6.7.</span> <span class="nav-text">ENV</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ARG"><span class="nav-number">3.3.6.8.</span> <span class="nav-text">ARG</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#VOLUME"><span class="nav-number">3.3.6.9.</span> <span class="nav-text">VOLUME</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#EXPOSE"><span class="nav-number">3.3.6.10.</span> <span class="nav-text">EXPOSE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WORKDIR"><span class="nav-number">3.3.6.11.</span> <span class="nav-text">WORKDIR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#USER"><span class="nav-number">3.3.6.12.</span> <span class="nav-text">USER</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MAINTAINER"><span class="nav-number">3.3.6.13.</span> <span class="nav-text">MAINTAINER</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ONBUILD"><span class="nav-number">3.3.6.14.</span> <span class="nav-text">ONBUILD</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用"><span class="nav-number">3.3.6.15.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实践"><span class="nav-number">3.3.6.16.</span> <span class="nav-text">实践</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器-1"><span class="nav-number">3.4.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#启动"><span class="nav-number">3.4.1.</span> <span class="nav-text">启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#终止容器"><span class="nav-number">3.4.2.</span> <span class="nav-text">终止容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进入容器"><span class="nav-number">3.4.3.</span> <span class="nav-text">进入容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除容器"><span class="nav-number">3.4.4.</span> <span class="nav-text">删除容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#导出和导入"><span class="nav-number">3.4.5.</span> <span class="nav-text">导出和导入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-Hub"><span class="nav-number">3.5.</span> <span class="nav-text">Docker Hub</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#推送镜像"><span class="nav-number">3.5.1.</span> <span class="nav-text">推送镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#提交构建文件到仓库"><span class="nav-number">3.5.2.</span> <span class="nav-text">提交构建文件到仓库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据管理"><span class="nav-number">3.6.</span> <span class="nav-text">数据管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据卷"><span class="nav-number">3.6.1.</span> <span class="nav-text">数据卷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器挂载数据卷"><span class="nav-number">3.6.2.</span> <span class="nav-text">容器挂载数据卷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#挂载主机文件作为数据卷"><span class="nav-number">3.6.3.</span> <span class="nav-text">挂载主机文件作为数据卷</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络"><span class="nav-number">3.7.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#外部访问容器"><span class="nav-number">3.7.1.</span> <span class="nav-text">外部访问容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器互联"><span class="nav-number">3.7.2.</span> <span class="nav-text">容器互联</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS"><span class="nav-number">3.7.3.</span> <span class="nav-text">DNS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器访问外网"><span class="nav-number">3.7.4.</span> <span class="nav-text">容器访问外网</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-Compose"><span class="nav-number">4.</span> <span class="nav-text">Docker Compose</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#了解"><span class="nav-number">4.1.</span> <span class="nav-text">了解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装-1"><span class="nav-number">4.2.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模板指令"><span class="nav-number">4.3.</span> <span class="nav-text">模板指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#build"><span class="nav-number">4.3.1.</span> <span class="nav-text">build</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cap-add-cap-drop"><span class="nav-number">4.3.2.</span> <span class="nav-text">cap_add, cap_drop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#command"><span class="nav-number">4.3.3.</span> <span class="nav-text">command</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cgroup-parent"><span class="nav-number">4.3.4.</span> <span class="nav-text">cgroup_parent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#container-name"><span class="nav-number">4.3.5.</span> <span class="nav-text">container_name</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#devices"><span class="nav-number">4.3.6.</span> <span class="nav-text">devices</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#depends-on"><span class="nav-number">4.3.7.</span> <span class="nav-text">depends_on</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dns"><span class="nav-number">4.3.8.</span> <span class="nav-text">dns</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dns-search"><span class="nav-number">4.3.9.</span> <span class="nav-text">dns_search</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tmpfs"><span class="nav-number">4.3.10.</span> <span class="nav-text">tmpfs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#env-file"><span class="nav-number">4.3.11.</span> <span class="nav-text">env_file</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#environment"><span class="nav-number">4.3.12.</span> <span class="nav-text">environment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#expose"><span class="nav-number">4.3.13.</span> <span class="nav-text">expose</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#extra-hosts"><span class="nav-number">4.3.14.</span> <span class="nav-text">extra_hosts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#healthcheck"><span class="nav-number">4.3.15.</span> <span class="nav-text">healthcheck</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#image"><span class="nav-number">4.3.16.</span> <span class="nav-text">image</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#labels"><span class="nav-number">4.3.17.</span> <span class="nav-text">labels</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#links"><span class="nav-number">4.3.18.</span> <span class="nav-text">links</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#logging"><span class="nav-number">4.3.19.</span> <span class="nav-text">logging</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#network-mode"><span class="nav-number">4.3.20.</span> <span class="nav-text">network_mode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#networks"><span class="nav-number">4.3.21.</span> <span class="nav-text">networks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pid"><span class="nav-number">4.3.22.</span> <span class="nav-text">pid</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ports"><span class="nav-number">4.3.23.</span> <span class="nav-text">ports</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#secrets"><span class="nav-number">4.3.24.</span> <span class="nav-text">secrets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#security-opt"><span class="nav-number">4.3.25.</span> <span class="nav-text">security_opt</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stop-signal"><span class="nav-number">4.3.26.</span> <span class="nav-text">stop_signal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sysctls"><span class="nav-number">4.3.27.</span> <span class="nav-text">sysctls</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ulimit"><span class="nav-number">4.3.28.</span> <span class="nav-text">ulimit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volumes"><span class="nav-number">4.3.29.</span> <span class="nav-text">volumes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volumes-from"><span class="nav-number">4.3.30.</span> <span class="nav-text">volumes_from</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#entrypoint"><span class="nav-number">4.3.31.</span> <span class="nav-text">entrypoint</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#privileged"><span class="nav-number">4.3.32.</span> <span class="nav-text">privileged</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#restart"><span class="nav-number">4.3.33.</span> <span class="nav-text">restart</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#working-dir"><span class="nav-number">4.3.34.</span> <span class="nav-text">working_dir</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#user"><span class="nav-number">4.3.35.</span> <span class="nav-text">user</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-1"><span class="nav-number">4.4.</span> <span class="nav-text">使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本的使用格式"><span class="nav-number">4.4.1.</span> <span class="nav-text">基本的使用格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用命令"><span class="nav-number">4.4.2.</span> <span class="nav-text">常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#build-1"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">build</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#config"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">config</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#down"><span class="nav-number">4.4.2.3.</span> <span class="nav-text">down</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exec"><span class="nav-number">4.4.2.4.</span> <span class="nav-text">exec</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#help"><span class="nav-number">4.4.2.5.</span> <span class="nav-text">help</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#images"><span class="nav-number">4.4.2.6.</span> <span class="nav-text">images</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#kill"><span class="nav-number">4.4.2.7.</span> <span class="nav-text">kill</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#logs"><span class="nav-number">4.4.2.8.</span> <span class="nav-text">logs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pause"><span class="nav-number">4.4.2.9.</span> <span class="nav-text">pause</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#port"><span class="nav-number">4.4.2.10.</span> <span class="nav-text">port</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ps"><span class="nav-number">4.4.2.11.</span> <span class="nav-text">ps</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pull"><span class="nav-number">4.4.2.12.</span> <span class="nav-text">pull</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#push"><span class="nav-number">4.4.2.13.</span> <span class="nav-text">push</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#restart-1"><span class="nav-number">4.4.2.14.</span> <span class="nav-text">restart</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rm"><span class="nav-number">4.4.2.15.</span> <span class="nav-text">rm</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#run"><span class="nav-number">4.4.2.16.</span> <span class="nav-text">run</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#scale"><span class="nav-number">4.4.2.17.</span> <span class="nav-text">scale</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#start"><span class="nav-number">4.4.2.18.</span> <span class="nav-text">start</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#stop"><span class="nav-number">4.4.2.19.</span> <span class="nav-text">stop</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#top"><span class="nav-number">4.4.2.20.</span> <span class="nav-text">top</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unpause"><span class="nav-number">4.4.2.21.</span> <span class="nav-text">unpause</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#up"><span class="nav-number">4.4.2.22.</span> <span class="nav-text">up</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#version"><span class="nav-number">4.4.2.23.</span> <span class="nav-text">version</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实践-1"><span class="nav-number">4.5.</span> <span class="nav-text">实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-Machine"><span class="nav-number">5.</span> <span class="nav-text">Docker Machine</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装-2"><span class="nav-number">5.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建本地主机驱动"><span class="nav-number">5.2.</span> <span class="nav-text">创建本地主机驱动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作命令"><span class="nav-number">5.3.</span> <span class="nav-text">操作命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-Swarm"><span class="nav-number">6.</span> <span class="nav-text">Docker Swarm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">6.1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#节点"><span class="nav-number">6.1.1.</span> <span class="nav-text">节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#服务和任务"><span class="nav-number">6.1.2.</span> <span class="nav-text">服务和任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建-Swarm-集群"><span class="nav-number">6.2.</span> <span class="nav-text">创建 Swarm 集群</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化集群"><span class="nav-number">6.2.1.</span> <span class="nav-text">初始化集群</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工作节点"><span class="nav-number">6.2.2.</span> <span class="nav-text">工作节点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#部署服务"><span class="nav-number">6.3.</span> <span class="nav-text">部署服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新建服务"><span class="nav-number">6.3.1.</span> <span class="nav-text">新建服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询服务"><span class="nav-number">6.3.2.</span> <span class="nav-text">查询服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除服务"><span class="nav-number">6.3.3.</span> <span class="nav-text">删除服务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-compose-文件部署"><span class="nav-number">6.4.</span> <span class="nav-text">使用 compose 文件部署</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#远程-API-架构"><span class="nav-number">7.</span> <span class="nav-text">远程 API 架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#了解-1"><span class="nav-number">7.1.</span> <span class="nav-text">了解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#daemon"><span class="nav-number">7.1.1.</span> <span class="nav-text">daemon</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#远程-API"><span class="nav-number">7.1.2.</span> <span class="nav-text">远程 API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开启远程-API"><span class="nav-number">7.2.</span> <span class="nav-text">开启远程 API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux"><span class="nav-number">7.2.1.</span> <span class="nav-text">Linux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Docker-Toolbox"><span class="nav-number">7.2.2.</span> <span class="nav-text">Docker Toolbox</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一些其他的问题解决"><span class="nav-number">8.</span> <span class="nav-text">一些其他的问题解决</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#更改Docker-默认镜像路径"><span class="nav-number">8.1.</span> <span class="nav-text">更改Docker 默认镜像路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WARNING-No-memory-limit-support"><span class="nav-number">8.2.</span> <span class="nav-text">WARNING: No memory limit support</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">9.</span> <span class="nav-text">Reference</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2017 - <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="powered-by" itemprop="copyrightHolder">Kai Zhang</span> <span class="site-pv"><i class="fa fa-eye"></i> <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div><div class="powered-by">Hosted by <a href="https://pages.coding.me" rel="external nofollow noopener noreferrer" target="_blank">Coding Pages</a></div><i class="fa fa-bar-chart"></i><div class="theme-info" style="margin-left:8px"><span class="post-count">Site words total count:225.9k</span></div><script type="text/javascript" src="https://zqnight.gitee.io/kaimz.github.io/js/high.js"></script><script>!function(){var t="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?f62559b2127396ecb27f4ed4f4652ea1":"https://jspassport.ssl.qhimg.com/11.0.1.js?f62559b2127396ecb27f4ed4f4652ea1";document.write('<script src="'+t+'" id="sozz"><\/script>')}()</script><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;w<0&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/44968c17.js","daovoice"),daovoice("init",{app_id:"44968c17"}),daovoice("update")</script><script type="text/javascript" src="https://zqnight.gitee.io/kaimz.github.io/js/clipboard.min.js"></script><script type="text/javascript" src="https://zqnight.gitee.io/kaimz.github.io/js/copy.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":100,"height":200},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html><!-- rebuild by neat -->