<!-- build time:Tue Nov 05 2019 23:20:50 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><script></script><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="-ZrQ5_gvorSDz6GoISTGIBaTjef2c3TFVkPfrA3d3XQ"><meta name="yandex-verification" content="be23233c5033cd4a"><meta name="baidu-site-verification" content="KFXVdNKQ18"><meta name="360-site-verification" content="bbd6f1a0727d8ef429be7131a051be20"><meta name="shenma-site-verification" content="719fb1b0c8f713194c5ac0387ee88673_1519303685"><meta name="msvalidate.01" content="EA3043B3BEC4629344CE5A71597718A0"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="1075199251,张凯,18772383543,wuwii,追光者w,有梦想的咸鱼,一棵树站在原野上,Slience"><link rel="alternate" href="/atom.xml" title="My Sunshine" type="application/atom+xml"><meta name="description" content="分析 AQS（队列同步器）AbstractQueuedSynchronizer （AQS），是用来构建所或者其他同步组件的基础框架，它使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的队列工作。源码版本 Jdk 1.8"><meta name="keywords" content="1075199251,张凯,18772383543,wuwii,追光者w,有梦想的咸鱼,一棵树站在原野上,Slience"><meta property="og:type" content="article"><meta property="og:title" content="Java 并发编程同步器 AQS"><meta property="og:url" content="http://blog.wuwii.com/java-aqs.html"><meta property="og:site_name" content="My Sunshine"><meta property="og:description" content="分析 AQS（队列同步器）AbstractQueuedSynchronizer （AQS），是用来构建所或者其他同步组件的基础框架，它使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的队列工作。源码版本 Jdk 1.8"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/1.png"><meta property="og:image" content="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/2.jpg"><meta property="og:image" content="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/3.jpg"><meta property="og:image" content="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/4.jpg"><meta property="og:image" content="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/5.png"><meta property="og:updated_time" content="2018-06-18T13:25:59.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java 并发编程同步器 AQS"><meta name="twitter:description" content="分析 AQS（队列同步器）AbstractQueuedSynchronizer （AQS），是用来构建所或者其他同步组件的基础框架，它使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的队列工作。源码版本 Jdk 1.8"><meta name="twitter:image" content="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/1.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!0,onmobile:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"TWXZ15WRBL",apiKey:"c272bd4b810c8b43773a3f1d3c6b8d27",indexName:"wuwii",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.wuwii.com/java-aqs.html"><link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><meta name="msapplication-TileColor" content="#da532c"><meta name="theme-color" content="#1f94aa"><title>Java 并发编程同步器 AQS | My Sunshine</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b847762b9271725a63131e554978de0a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(){var e=document.createElement("script");e.src="//tajs.qq.com/stats?sId=63798915";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><link href="https://zqnight.gitee.io/kaimz.github.io/css/harlem-shake-style.css" rel="stylesheet" type="text/css"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><div class="forkme"><a rel="external nofollow noopener noreferrer" href="https://github.com/kaimz" target="_blank"><img style="position:absolute;top:0;left:0;border:0" src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png" alt="Fork me on GitHub"></a></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">My Sunshine</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">鸣谢生命有你参与 笑纳我的邀请。</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav><canvas id="wobblew" width="1056" height="150" style="position:absolute;z-index:-1;left:0;top:0"></canvas></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.wuwii.com/java-aqs.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Kai Zhang"><meta itemprop="description" content=""><meta itemprop="image" content="http://oss.wuwii.com/image/head/%E6%97%A0%E9%99%90.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="My Sunshine"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">Java 并发编程同步器 AQS</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T11:11:03+08:00">2018-05-18 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">10,789 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长</span> <span title="阅读时长">46</span></div></div></header><div class="post-body" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="分析-AQS（队列同步器）"><a href="#分析-AQS（队列同步器）" class="headerlink" title="分析 AQS（队列同步器）"></a>分析 AQS（队列同步器）</h3><p><code>AbstractQueuedSynchronizer</code> （AQS），是用来构建所或者其他同步组件的基础框架，它使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的队列工作。</p><p><em>源码版本 Jdk 1.8</em></p><a id="more"></a><h4 id="怎么实现队列同步器"><a href="#怎么实现队列同步器" class="headerlink" title="怎么实现队列同步器"></a>怎么实现队列同步器</h4><p>同步器主要的使用方式是继承，子类实现它的部分方法来管理同步状态变量就可以了。</p><p>简单的说，同步器，使用一个状态 <code>state:int</code> 表示它的状态变化，如果有其他的锁需要使用 AQS ，需要操作这个状态变量，AQS 直接提供了三个方法供修改状态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 获取当前同步资源状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> state;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 设置当前同步状态</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">long</span> newState)</span> </span>&#123;</span><br><span class="line">       state = newState;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// CAS 操作 设置当前状态，该方法保证状态设置的原子性。</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">       <span class="keyword">return</span> unsafe.compareAndSwapLong(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>同步器是一个 CLH 队列（FIFO），队列中的元素Node就是保存着线程引用和线程状态的容器，每个线程对同步器的访问，都可以看做是队列中的一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> waitStatus;</span><br><span class="line">    Node prev;</span><br><span class="line">    Node next;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">    Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td>int waitStatus</td><td>表示节点的状态。其中包含的状态有：<br><code>CANCELLED</code>，值为1，表示当前的线程被取消；<br><code>SIGNAL</code>，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；<br><code>CONDITION</code>，值为-2，表示当前节点在等待condition，也就是在condition队列中；<br><code>PROPAGATE</code>，值为-3，表示当前场景下后续的acquireShared能够得以执行；<br>值为0，表示当前节点在sync队列中，等待着获取锁。</td></tr><tr><td>Node prev</td><td><strong>前驱节点</strong>，比如当前节点被取消，那就需要前驱节点和后继节点来完成连接。</td></tr><tr><td>Node next</td><td><strong>后继节点</strong>。</td></tr><tr><td>Node nextWaiter</td><td>存储condition队列中的后继节点。</td></tr><tr><td>Thread thread</td><td>入队列时的当前线程。</td></tr></tbody></table><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/1.png" alt="image"></p><p>当前占有资源的节点就是头节点。</p><p>AQS 定义两种资源共享方式：</p><ul><li><code>Exclusive</code>：独占模式，又称排他模式，只能有一个线程占用资源，如 ReentrantLock；</li><li><code>Share</code>：共享模式，多个线程可以一起执行，同时占用资源。</li></ul><p>同步器对外部使用者提供五个方法，让锁使用资源的方法，主需要实现其中的部分方法，实现对共享资源的获取和释放就可以了。</p><ul><li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><h4 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h4><h5 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行 CAS 设置同步状态。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           <span class="comment">// 上面判断如果为 true 的话，表示该等待的线程被中断过，但是等待过程中不能响应中断消息，获取资源后再自我中断，并且释放</span></span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试去获取资源状态，如果获取成功，返回 true，这里没有去实现方法，需要锁中自己去实现。</span></span><br><span class="line"><span class="comment">// 这里没有直接使用抽象方法，因为考虑到独占模式只实现 tryAcquire-tryRelease 这两个方法；而贡献模式只用实现tryAcquireShared-tryReleaseShared 这两个方法，避免都要去实现。</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在上一步中获取线程资源失败后，我们后面要做的就是让该线程加入到等待队列中。</span></span><br><span class="line"><span class="comment">// 为当前线程创建一个节点，同步器的模式为参数 mode 模式进入等待队列的队尾，并返回构造好的节点。</span></span><br><span class="line"><span class="comment">// @param mode 指定模式：EXCLUSIVE（独占）和SHARED（共享）</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">       Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">       <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">       Node pred = tail;</span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">           node.prev = pred;</span><br><span class="line">           <span class="comment">// 设置尾节点的时候需要线程安全，需要基于 CAS 操作设置尾节点，只有设置成功后当前节点才能正式与之前的尾节点进行联系。</span></span><br><span class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">               pred.next = node;</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果队尾为 null 的时候，不能快速的入队操作，将使用 enq</span></span><br><span class="line">       enq(node);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个 node 节点 加入队尾，返回上一个尾节点。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// CAS自旋volatile变量</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node t = tail;</span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">               <span class="comment">// 队尾为 null 的话，证明该队列是空的，需要进行初始化；</span></span><br><span class="line">               <span class="comment">// 初始化一个队列，头节点为空的，尾节点指向头节点。</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               node.prev = t;</span><br><span class="line">               <span class="comment">// 直到拿到锁，</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next = node;</span><br><span class="line">                   <span class="keyword">return</span> t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 前面的步骤都是：当线程获取资源失败后，怎么样将线程放入到等待队列的队尾。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一步就是当前线程放入到等待队列后，需要等待其他线程使用完资源释放，自己去获取资源。</span></span><br><span class="line"><span class="comment">// 如果获取到资源就返回</span></span><br><span class="line"><span class="comment">// 如果 node 节点的线程线程中断过，就返回 true</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>; <span class="comment">// 最终是否成功获得资源</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">// 标记线程是否被中断</span></span><br><span class="line">           <span class="comment">// 自旋锁</span></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 获得指定节点的前驱节点 prev</span></span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 如果该节点的前驱节点是 head 节点，则去尝试获取资源，</span></span><br><span class="line">                   <span class="comment">// 头节点拿到资源</span></span><br><span class="line">                   setHead(node); <span class="comment">// 拿到资源将该 Head 指向该节点，并且将线程的引用置 Null</span></span><br><span class="line">                   <span class="comment">// 由于只有一个线程能够获取到资源，因此设置头节点的时候，不需要 AQS 操作，直接设置即可。</span></span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC ，拿到资源后，将原头节点从队列中完全拿出来，让系统回收资源</span></span><br><span class="line">                   failed = <span class="keyword">false</span>; <span class="comment">// 标记已经成功拿到资源</span></span><br><span class="line">                   <span class="keyword">return</span> interrupted; </span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 没有拿到资源，进入等待状态，并且检查是否被中断过。</span></span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = <span class="keyword">true</span>; <span class="comment">// 线程中断过</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node); <span class="comment">// 出现异常，但没有成功获取获取到资源，取消该线程</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要是去检查前面的线程是否是在等待准备运行，避免已经放弃了的线程节点，去寻找一个安全点（等待状态 waitStatus = 0）</span></span><br><span class="line"><span class="comment">// 前节点状态是SIGNAL时，当前线程需要阻塞，等待被它唤醒；</span></span><br><span class="line"><span class="comment">// 前节点状态是CANCELLED时，通过循环将当前节点之前所有取消状态的节点移出队列；</span></span><br><span class="line"><span class="comment">// 前节点状态是其他状态时，需要设置前节点为SIGNAL。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//拿到前驱的状态</span></span><br><span class="line">       <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">           <span class="comment">//如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span></span><br><span class="line"><span class="comment">            * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               node.prev = pred = pred.prev;</span><br><span class="line">           &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">           pred.next = node;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span></span><br><span class="line">           compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//  上一步执行完毕 如果返回 true，表示自己要安心休息了，就开始执行这个步骤</span></span><br><span class="line"><span class="comment">// 返回 true ，表示当前线程中断过。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       LockSupport.park(<span class="keyword">this</span>); <span class="comment">// LockSupport.park 底层实现，让该线程进入等待状态</span></span><br><span class="line">       <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 返回检查当前线程是否被中断过</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>总结 <code>acquire</code> 流程：</p><ol><li>使用 <code>tryAcquire()</code>尝试直接去获取资源，如果成功则直接返回；</li><li>如果上一步没有成功，<code>tryAcquire()</code>尝试直接去获取资源，如果成功则直接返回；</li><li><code>acquireQueued()</code> 让线程进入等待队列中自旋，当轮到自己去获取资源的时候，采取尝试获取资源，如果被中断过，则返回 <code>true</code>，如果返回 <code>false</code> 则直接返回；</li><li>如果上一步返回 true，表示线程被中断过，但是在等待过程中是不响应的，获取到资源的时候，才去将本线程进行中断。</li></ol><h5 id="release"><a href="#release" class="headerlink" title="release"></a>release</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123; <span class="comment">// 尝试去释放节点</span></span><br><span class="line">           Node h = head; <span class="comment">// 找到头节点</span></span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">// 判断该线程状态，主要是查看后面有没有节点需要它来唤醒的。</span></span><br><span class="line">               unparkSuccessor(h); <span class="comment">// 如果有线程需要它去唤醒，就去唤醒等待队列中的下一个线程</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;    </span><br><span class="line"><span class="comment">// 注意在独占模式下，这个方法是线程安全的，直接 setState(0) 释放资源即可。</span></span><br><span class="line"><span class="comment">// 释放完所有的资源（state = 0 ） ，返回  true。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 唤醒等待队列中的最前面节点的状态未取消的线程。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">        * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">        * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">       <span class="comment">// 如果当前等待线程的标志没有取消，则将线程节点的状态置 0，</span></span><br><span class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">           compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">// 升级为等待状态</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">        * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">        * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">        * non-cancelled successor.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// 开始去唤醒下一个节点</span></span><br><span class="line">       Node s = node.next;</span><br><span class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// 判断下个线程为空或者已经取消</span></span><br><span class="line">           s = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 当下个节点是无效节点的时候，然后从尾节点开始遍历寻找有效节点，作为下个节点</span></span><br><span class="line">               <span class="comment">// 所以这里有个疑问，为什么要从尾节点开始遍历？</span></span><br><span class="line">               <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   s = t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">           LockSupport.unpark(s.thread); <span class="comment">// 唤醒下个线程，也只是唤醒一个有效线程状态</span></span><br><span class="line">       <span class="comment">// 既然参与竞争，它是等待队列中排在最前面的等待队列，经过前面的 shouldParkAfterFailedAcquire 调整，一定是 Head 的后继节点，下次自旋的时候，拿到资源的条件成立。</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里为什么从开始尾节点遍历，<a href="https://my.oschina.net/xianggao/blog/532709" rel="external nofollow noopener noreferrer" target="_blank">参考文章</a></p><p>因为在CLH队列中的结点随时有可能被中断，<code>被中断的结点的waitStatus设置为CANCEL,而且它会被踢出CLH队列</code>，如何个踢出法，就是它的前趋结点的next并不会指向它，而是指向下一个非CANCEL的结点,而它自己的next指针指向它自己（将自己踢出，并让 GC 回收）。一旦这种情况发生，如何从头向尾方向寻找继任结点会出现问题，<code>因为一个CANCEL结点的next为自己，那么就找不到正确的继任接点</code>。</p><p><strong>总结下 release：</strong></p><p>需要独占模式中自定义的同步器子类去实现，用来释放资源，释放相应的资源，将 state 减少相应的数量即可，如果完全释放了资源，唤醒等待队列中有效的线程来获取资源。</p><ol><li>处理当前节点：非CANCELLED状态重置为0；</li><li>寻找下个节点：如果是CANCELLED状态，说明节点中途溜了，从队列尾开始寻找排在最前还在等着的节点</li><li>唤醒：利用LockSupport.unpark唤醒下个节点里的线程。</li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/2.jpg" alt="image"></p><ol><li>获取资源的时候，队列同步器中每个节点都是一个线程在进行自旋，如果该节点的前驱节点是头节点，它就可以去获取资源，退出自旋的时候，将本线程的节点设置成头节点；</li><li>释放资源的时候，将本线程的等待状态改成 0 （等待状态），然后让下一个小于 0 的有效节点的节点状态改成 0（等待状态），然后资源状态。</li><li>只有当前节点的前一个节点为 <code>SIGNAL</code> 时，才能当前节点才能被挂起。对线程的挂起及唤醒操作是通过使用 LockSupport 类的 <code>park/unpark</code> 实现的。</li></ol><h5 id="doAcquireNanos"><a href="#doAcquireNanos" class="headerlink" title="doAcquireNanos"></a>doAcquireNanos</h5><p>该方法提供了具备有超时功能的获取状态的调用，如果在指定的<code>nanosTimeout</code>内没有获取到状态，那么返回false，反之返回true。可以将该方法看做acquireInterruptibly的升级版，也就是在判断是否被中断的基础上增加了超时控制。<br>针对超时控制这部分的实现，主要需要计算出睡眠的delta，也就是间隔值。间隔可以表示为 nanosTimeout 等于原有<code>nanosTimeout – now（当前时间）+ lastTime（睡眠之前记录的时间）</code>。如果nanosTimeout大于0，那么还需要使当前线程睡眠，反之则返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 独占式超时获取资源</span></span><br><span class="line"><span class="comment">// 在指定时间段内获取资源，成功返回 true </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">long</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout; <span class="comment">// 计算最终超时事件</span></span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE); <span class="comment">// 独占模式加入到等待队列中</span></span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">// 自旋</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 没有获取到资源开始工作……</span></span><br><span class="line">               nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">               <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) <span class="comment">// 超时</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   nanosTimeout &gt; spinForTimeoutThreshold) <span class="comment">// &gt; 1000ns ，超时时间在 1000 ns 内 ，线程自旋中，否则线程进入阻塞状态。</span></span><br><span class="line">                   <span class="comment">// 设置线程还应该睡眠多长时间，避免等待时间过长期间的不断重试。</span></span><br><span class="line">                   LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">               <span class="comment">// 中断信号直接中断</span></span><br><span class="line">               <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/3.jpg" alt="image"></p><h4 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h4><h5 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 共享模式获取资源，获取成功则返回，获取失败进入同步等待队列中，整个过程忽略线程中断。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">           doAcquireShared(arg);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 需要自定义同步器去实现，</span></span><br><span class="line"><span class="comment">// 负值代表获取失败；</span></span><br><span class="line"><span class="comment">// 0 代表获取成功，刚好获取剩下的一个资源，没有资源再分配后面的线程；。</span></span><br><span class="line"><span class="comment">// 正数表示获取成功，返回剩余的资源数量。</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取资源失败后，进入等待队列，自旋，直到获取资源才返回。</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">// 设置共享模式</span></span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>; <span class="comment">// 设置是否获取资源成功标志</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">// 等待过程中，中断标志</span></span><br><span class="line">           <span class="comment">// 自旋</span></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">//获得前驱节点</span></span><br><span class="line">               <span class="comment">// 如果前驱节点是头节点，则取尝试获取资源</span></span><br><span class="line">               <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                   <span class="keyword">long</span> r = tryAcquireShared(arg);</span><br><span class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 如果获取资源成功后，就设置头节点为自己（node）</span></span><br><span class="line">                       setHeadAndPropagate(node, r); </span><br><span class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                       <span class="keyword">if</span> (interrupted) <span class="comment">// 如果等待过程中出现线程中断就自己中断线程</span></span><br><span class="line">                           selfInterrupt();</span><br><span class="line">                       failed = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 判断状态，找到安全点，进入等待状态，等待被唤醒，如果被中断，则补上中断标志</span></span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed) <span class="comment">// 出现异常，取消该线程</span></span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 唤醒符合条件的其他线程</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">long</span> propagate)</span> </span>&#123;</span><br><span class="line">       Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">       setHead(node); <span class="comment">// 将头节点指向 node 节点</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">        *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">        *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">        *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">        *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">        *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">        * and</span></span><br><span class="line"><span class="comment">        *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">        *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">        * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">        * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">        * anyway.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// 还有资源剩下，则继续唤醒后继节点的线程</span></span><br><span class="line">       <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">           (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           Node s = node.next;</span><br><span class="line">           <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">               doReleaseShared();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol><li><code>tryAcquireShared()</code>尝试获取资源，成功则直接返回；</li><li>失败则通过<code>doAcquireShared()</code> 进入等待队列 <code>park()</code>，直到被 <code>unpark()</code> / <code>interrupt()</code>并成功获取到资源才返回。整个等待过程也是忽略中断的。</li></ol><h5 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="comment">// 尝试释放资源</span></span><br><span class="line">           doReleaseShared(); <span class="comment">// 释放资源成功，唤醒后继节点取竞争资源</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 根据作者写这个方法的注释，表达的意思是释放一个或者以上的资源就返回 true，</span></span><br><span class="line"><span class="comment">// 但是实际情况下，ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以这个可以根据自己的实际情况进行更改的。</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 唤醒后继 </span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 自旋</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">               <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">               <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// 判断后继节点是否需要运行</span></span><br><span class="line">                   <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) <span class="comment">// 将头节点设置成等待状态</span></span><br><span class="line">                       <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                   unparkSuccessor(h); <span class="comment">// 唤醒后继</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) <span class="comment">// 如果头节点为等待状态了，则设置节点状态需要往后面的节点传播</span></span><br><span class="line">                   <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">               <span class="keyword">break</span>; </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Mutex（独占锁）"><a href="#Mutex（独占锁）" class="headerlink" title="Mutex（独占锁）"></a>Mutex（独占锁）</h4><p>具体是参考《Java 并发编程艺术》一书第五章：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断是否是占有状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取资源，立即返回。成功则返回true</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);<span class="comment">//释放资源，放弃占有状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作全部依赖于AQS自定义的同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取资源，要求立即返回。成功则为true，失败则为false。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁是否占有状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>定义一个静态内部类继承类同步器并实现了独占模式的操作方法；</li><li>获取资源 tryAcquire 中，CAS 获取资源，获取成功返回 true；</li><li>释放资源 tryRelealse，将资源设置为0；</li></ol><p>测试一下（每过一秒打印一个结果）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutexTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Mutex mutex = <span class="keyword">new</span> Mutex();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mutex.lock();</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(j);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mutex.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">------------</span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span></span><br><span class="line">------------</span><br><span class="line"><span class="number">2</span></span><br><span class="line">------------</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">------------</span><br></pre></td></tr></table></figure><h4 id="TwinsLock（共享锁）"><a href="#TwinsLock（共享锁）" class="headerlink" title="TwinsLock（共享锁）"></a>TwinsLock（共享锁）</h4><p>具体是参考《Java 并发编程艺术》一书第五章：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义的同步器，能够有两个线程同时获取资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count must large than zero."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> reduceCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current - reduceCount;</span><br><span class="line">                <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> returnCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current + returnCount;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, newCount)) &#123; <span class="comment">// 将释放的资源返回</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Condition <span class="title">newCondtion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireShared(<span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondtion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TwinsLock 包含了一个自定义的同步器 sync，该同步器以共享方式获取同步状态。当 消耗资源<code>tryAcquireShared(int reduceCount)</code> 大于 或者等于 0 的时候，表示当前线程获取锁成功。</p><p>验证上面锁的正确性，就是要验证是否同一时刻有两个线程同时进行打印任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLockTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> TwinsLock();</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Worker().start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Thread-<span class="number">5</span></span><br><span class="line">Thread-<span class="number">2</span></span><br><span class="line"></span><br><span class="line">Thread-<span class="number">1</span></span><br><span class="line">Thread-<span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line">Thread-<span class="number">9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread-<span class="number">4</span></span><br><span class="line">Thread-<span class="number">3</span></span><br><span class="line"></span><br><span class="line">Thread-<span class="number">7</span></span><br><span class="line">Thread-<span class="number">8</span></span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>在这个 AQS 同步器中我们时刻需要更改注意两个方面的问题：</p><ul><li><p>一是要去维护同步队列，更改同步器的资源状态变量，通过 <code>Unsafe</code> 提供原子操作 CAS；</p></li><li><p>二是底层还要去根据同步器状态变量去实现线程等待，线程唤醒的，它是通过 <code>LockSupport</code> 的 <code>park/unpark</code> 操作。<br>当然使用者不需要注意这些问题，代码已经把这些方法都已经封装好了，只要实现资源变量的变化的几个方法就可以了。</p></li><li><p>如果是要使用独占模式，只需要实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br></pre></td></tr></table></figure></li><li><p>如果只是要使用共享模式，需要实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="补充：CLH-队列锁"><a href="#补充：CLH-队列锁" class="headerlink" title="补充：CLH 队列锁"></a>补充：CLH 队列锁</h4><p>就是源码分析中那个同步队列，节点单位就是内部类 Node，获取锁的时候跟队列的头有关，释放锁主要删除头节点和从尾节点唤醒。它虽然保留了自旋操作，但是真实情况下，是阻塞了线程（LockSupport）。</p><h4 id="补充：CAS"><a href="#补充：CAS" class="headerlink" title="补充：CAS"></a>补充：CAS</h4><p>这部分参考文章 <a href="https://www.jianshu.com/p/e2179c74a2e4?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_all_hots&amp;utm_source=recommendation" rel="external nofollow noopener noreferrer" target="_blank">认识非阻塞的同步机制CAS</a></p><blockquote><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论V值是否等于A值，都将返回V的原值。</p></blockquote><p>当多个线程尝试使用CAS同时更新一个变量，最终只有一个线程会成功，其他线程都会失败。但和使用锁不同，失败的线程不会被阻塞，而是被告之本次更新操作失败了，可以再试一次。此时，线程可以根据实际情况，继续重试或者跳过操作，大大减少因为阻塞而损失的性能。所以，CAS是一种乐观的操作，它希望每次都能成功地执行更新操作。</p><p><strong>AQS 中的 CAS 由 <code>Unsafe</code> 提供。</strong></p><h4 id="补充：自旋锁"><a href="#补充：自旋锁" class="headerlink" title="补充：自旋锁"></a>补充：自旋锁</h4><p>这部分参考文章 <a href="http://www.cnblogs.com/thomaschen750215/p/4122068.html" rel="external nofollow noopener noreferrer" target="_blank">CAS和自旋锁(spin lock)</a></p><blockquote><p>由于在多处理器系统环境中有些资源因为其有限性，有时需要互斥访问（mutual exclusion），这时会引入锁的机制，只有获取了锁的进程才能获取资源访问。即是每次只能有且只有一个进程能获取锁，才能进入自己的临界区，同一时间不能两个或两个以上进程进入临界区，当退出临界区时释放锁。设计互斥算法时总是会面临一种情况，即没有获得锁的进程怎么办？通常有2种处理方式。一种是没有获得锁的调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，这就是自旋锁，他不用将线城阻塞起来（NON-BLOCKING)；另一种是没有获得锁的进程就阻塞(BLOCKING)自己，请求OS调度另一个线程上处理器，这就是互斥锁。</p></blockquote><p>跟互斥锁一样，一个执行单元要想访问被自旋锁保护的共享资源，必须先得到锁，在访问完共享资源后，必须释放锁。如果在获取自旋锁时，没有任何执行单元保持该锁，那么将立即得到锁；如果在获取自旋锁时锁已经有保持者，那么获取锁操作将自旋在那里，直到该自旋锁的保持者释放了锁。由此我们可以看出，自旋锁是一种比较低级的保护数据结构或代码片段的原始方式，这种锁可能存在两个问题：</p><ul><li><strong>递归死锁</strong>：试图递归地获得自旋锁必然会引起死锁：递归程序的持有实例在第二个实例循环，以试图获得相同自旋锁时，不会释放此自旋锁。在递归程序中使用自旋锁应遵守下列策略：递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。此外如果一个进程已经将资源锁定，那么，即使其它申请这个资源的进程不停地疯狂“自旋”,也无法获得资源，从而进入死循环。</li><li><strong>过多占用cpu资源</strong>。如果不加限制，由于申请者一直在循环等待，因此自旋锁在锁定的时候,如果不成功,不会睡眠,会持续的尝试,单cpu的时候自旋锁会让其它process动不了. 因此，一般自旋锁实现会有一个参数限定最多持续尝试次数. 超出后, 自旋锁放弃当前time slice. 等下一次机会</li></ul><p>​ 由此可见，自旋锁比较适用于锁使用者保持锁时间比较短的情况。正是由于自旋锁使用者一般保持锁时间非常短，因此选择自旋而不是睡眠是非常必要的，自旋锁的效率远高于互斥锁。</p><h4 id="补充：LockSupport"><a href="#补充：LockSupport" class="headerlink" title="补充：LockSupport"></a>补充：LockSupport</h4><p>具体内容请参考 <a href="https://www.jianshu.com/p/e3afe8ab8364" rel="external nofollow noopener noreferrer" target="_blank">LockSupport（park/unpark）源码分析</a></p><p><code>LockSupport.park()</code>和 <code>LockSupport.unpark(Thread thread)</code>调用的是 <code>Unsafe</code>中本地方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//park</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unpack</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br></pre></td></tr></table></figure><p><code>park</code> 函数是将当前调用Thread阻塞，而 <code>unpark</code> 函数则是将指定线程唤醒。</p><h3 id="ReentrantLock-独占锁"><a href="#ReentrantLock-独占锁" class="headerlink" title="ReentrantLock(独占锁)"></a>ReentrantLock(独占锁)</h3><p><a href="https://www.jianshu.com/p/fe027772e156" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/fe027772e156</a></p><p>其实 ReentantLock 的实现和上面的例子 <code>Mutex</code> 的差不多，不过它另外实现了可重入和公平锁两个部分。</p><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">   <span class="keyword">int</span> c = getState();</span><br><span class="line">   <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">           compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">           setExclusiveOwnerThread(current);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">       <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">       <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">       setState(nextc);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比非公平锁，它多了一个方法<code>hasQueuedPredecessors</code> 判断队列是否有排在前面的线程在等待锁，没有的话调用<code>compareAndSetState</code> 使用 CAS 的方式修改state，然后设置本线程为独占锁，并且它是可重入锁。</p><h3 id="ReentrantReadWriteLock（读写锁）"><a href="#ReentrantReadWriteLock（读写锁）" class="headerlink" title="ReentrantReadWriteLock（读写锁）"></a>ReentrantReadWriteLock（读写锁）</h3><p>首先来分析下读写锁的几个重要的特点：</p><ol><li>读写状态的设计；</li><li>写锁的获取与释放；</li><li>读锁的获取与释放；</li><li>锁降级的实现。</li></ol><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">   &#125;	</span><br><span class="line"><span class="comment">// 提供公平锁，默认是非公平锁    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">       sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">       readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">       writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="读写状态设计"><a href="#读写状态设计" class="headerlink" title="读写状态设计"></a>读写状态设计</h4><p>在读写锁中最重要的就是Sync类，它继承自AQS，还记得吗，AQS使用一个int型来保存状态，状态在这里就代表锁，它提供了获取和修改状态的方法。可是，这里要实现读锁和写锁，只有一个状态怎么办？Doug Lea是这么做的，它把状态的高16位用作读锁，低16位用作写锁，所以无论是读锁还是写锁最多只能被持有65535次。所以在判断读锁和写锁的时候，需要进行位运算：</p><p><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/4.jpg" alt="image"></p><ol><li>由于读写锁共享状态，所以状态不为0，只能说明是有锁，可能是读锁，也可能是写锁；</li><li>读锁是高16为表示的，所以读锁加1，就是状态的高16位加1，低16位不变，所以要加的不是1，而是2^16，减一同样是这样。</li><li>写锁用低16位表示，要获得写锁的次数，要用状态&amp;2^16-1，结果的高16位全为0，低16位就是写锁被持有的次数。</li></ol><p>那它是怎么确定读写的各自的状态的了，是通过位运算符，假设当前同步状态值为 S，写状态等于 <code>S &amp; 0x0000FFFF</code>（只有 低 16 位），读状态等于 <code>S &gt;&gt;&gt; 16</code> （无符号补位右移 16 位）；这个时候写状态增加 1 时，等于 <code>S + 1</code>，当读状态增加 1，等于 <code>S + (1 &lt;&lt; 16)</code>，也就是 <code>S + 0x00010000</code>。</p><p>根据状态的划分可以得出一个结论： S 不等于 0 时，就是写状态计算公式 <code>S &amp; 0x0000FFFF == 0</code>，则读状态 <code>S &gt;&gt;&gt; 16 &gt; 0</code> 这个时候，读锁获取到了。</p><h4 id="同步器的设计"><a href="#同步器的设计" class="headerlink" title="同步器的设计"></a>同步器的设计</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//ReentrantReadWriteLock的同步器</span></span><br><span class="line"><span class="comment">// 分别用子类来实现公平和非公平策略  </span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6317671515068378041L</span>;  </span><br><span class="line"> </span><br><span class="line">      <span class="comment">//高16位表示持有读锁的计数 </span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;  </span><br><span class="line">      <span class="comment">//由于读锁用高位部分，读锁个数加1，其实是状态值加 2^16  </span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT); </span><br><span class="line">      <span class="comment">// 所以读锁或者写锁分别最多线程数为 2^16 = 65535</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;  </span><br><span class="line">      <span class="comment">// 低16位表示写锁计数，</span></span><br><span class="line">      <span class="comment">// 写锁的掩码，用于状态的低16位有效值 </span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;  </span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 获取读锁（共享锁）的数量</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;  </span><br><span class="line">      <span class="comment">// 获取写锁（独占锁）的重入次数</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;  </span><br><span class="line"> </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 每个线程特定的 read 持有计数。存放在ThreadLocal，不需要是线程安全的。</span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">int</span> count = <span class="number">0</span>;  </span><br><span class="line">          <span class="comment">//使用id而不是引用是为了避免保留垃圾。注意这是个常量。  </span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> tid = Thread.currentThread().getId();  </span><br><span class="line">      &#125;  </span><br><span class="line"> </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 采用继承是为了重写 initialValue 方法，这样就不用进行这样的处理： </span></span><br><span class="line"><span class="comment">       * 如果ThreadLocal没有当前线程的计数，则new一个，再放进ThreadLocal里。 </span></span><br><span class="line"><span class="comment">       * 可以直接调用 get。 </span></span><br><span class="line"><span class="comment">       * */</span>  </span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span>  </span></span><br><span class="line"><span class="class">          <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;  </span><br><span class="line">          <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 当前线程持有的可重入读锁的数量，仅在构造方法和readObject(反序列化) </span></span><br><span class="line"><span class="comment">       * 时被初始化，当持有锁的数量为0时，移除此对象。 </span></span><br><span class="line"><span class="comment">       * 它存储了当前线程的 HoldCounter ，而HoldCounter中的count变量就是用来记录线程获得的写锁的个数。</span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;  </span><br><span class="line"> </span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * 最近一个成功获取读锁的线程的计数。这省却了ThreadLocal查找， </span></span><br><span class="line"><span class="comment">       * 通常情况下，下一个释放线程是最后一个获取线程。这不是 volatile 的， </span></span><br><span class="line"><span class="comment">       * 因为它仅用于试探的，线程进行缓存也是可以的 </span></span><br><span class="line"><span class="comment">       * （因为判断是否是当前线程是通过线程id来比较的）。 </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;  </span><br><span class="line">     </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      	* firstReader是第一个获得读锁的线程； </span></span><br><span class="line"><span class="comment">       * firstReaderHoldCount是firstReader的重入计数； </span></span><br><span class="line"><span class="comment">       * 更准确的说，firstReader是最后一个把共享计数从0改为1，并且还没有释放锁。 </span></span><br><span class="line"><span class="comment">       * 如果没有这样的线程，firstReader为null; </span></span><br><span class="line"><span class="comment">       * firstReader不会导致垃圾堆积，因为在tryReleaseShared中将它置空了，除非 </span></span><br><span class="line"><span class="comment">       * 线程异常终止，没有释放读锁。 </span></span><br><span class="line"><span class="comment">       *  </span></span><br><span class="line"><span class="comment">       * 跟踪无竞争的读锁计数时，代价很低 </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;  </span><br><span class="line"> </span><br><span class="line">      Sync() &#123;  </span><br><span class="line">          readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();  </span><br><span class="line">          setState(getState()); <span class="comment">// ensures visibility of readHolds  </span></span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 下面两个抽象方法用来实现读锁或者写锁是否需要阻塞。</span></span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span></span>;<span class="comment">//写锁是否需要阻塞</span></span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span></span>;<span class="comment">//读锁是否需要阻塞</span></span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 下面是非公平锁的实现</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line">       <span class="comment">// 持有写锁可重入，不需要阻塞。</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 根据下一个节点是不是写锁（独占锁）确定它是否阻塞</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">            * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">            * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">            * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">            * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">            * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//  AQS 提供的方法，判断下一个节点是独占锁</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Node h, s;</span><br><span class="line">       <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           !s.isShared()         &amp;&amp;</span><br><span class="line">           s.thread != <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">// 公平锁的实现，只要当前线程前面还有线程需要获取锁，都要进行阻塞。    </span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// AQS 提供的方法，和 ReentrantLock 里面同步锁实现一样的，判断该线程前面有没有线程在等待获取锁   </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">       <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">       <span class="comment">// thread is first in queue.</span></span><br><span class="line">       Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">       Node h = head;</span><br><span class="line">       Node s;</span><br><span class="line">       <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">           ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="写锁的获取和释放"><a href="#写锁的获取和释放" class="headerlink" title="写锁的获取和释放"></a>写锁的获取和释放</h4><p>首先，写锁是一个可重入的排他锁，如果当前线程获取到了写锁，则增加写状态，如果读锁或者写锁已经被获取了，它则进入等待状态（写锁要确保写锁的操作对读锁可见）。</p><p>写锁和对外提供的方法和 ReentrantLock 一样的，这里主要去分析下它是怎么获取和释放资源的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 检查当前线程是不是独占模式</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases; <span class="comment">// 计算释放后的资源数量</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>); <span class="comment">// 如果写锁都执行完了，释放写锁。</span></span><br><span class="line">    setState(nextc); <span class="comment">// 写入释放完资源的数量</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">     *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">     *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">     * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">     *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">     *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">     *    and set owner.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 获取写锁的数量</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123; <span class="comment">// 如果 state 不为 0 表示锁已经分配出去了</span></span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread()) <span class="comment">//如果其他线程获取了写锁则获取失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        setState(c + acquires); <span class="comment">// 经过上面的检查后，表示写锁可以重入，并返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于要首次获取写锁，如果允许获取写锁， CAS 操作 获取独占锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取锁：<br><img src="https://zqnight.gitee.io/kaimz.github.io/image/hexo/java-aqs/5.png" alt="image"></p><p>获取锁的过程：</p><ol><li>首先获取写锁的数量；</li><li>判断写锁是否已经被获取了，如果已经获取了，就要做重入操作，将锁的资源数量加一，然后返回；如果是首次获取，就要进行 CAS 操作获取独占锁；</li></ol><p>释放锁的过程：</p><ol><li>计算如果释放完资源的数量；</li><li>如果剩下的资源数量为 0，则释放写锁；</li><li>如果剩下的资源数量不为 0，就将计算完的资源数量写入。</li></ol><h4 id="读锁的获取和释放"><a href="#读锁的获取和释放" class="headerlink" title="读锁的获取和释放"></a>读锁的获取和释放</h4><p>读锁是一个支持<strong>重入</strong>的<strong>共享锁</strong>，它能够被多个线程同时获取，当写锁的状态为 0 的时候，读锁总是获取成功的，并且增加读状态。这里比较复杂些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 先处理本地本地计数器</span></span><br><span class="line">    <span class="comment">// 判断当前线程是否为第一个读线程firstReader</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="comment">// 如果当前线程读锁重入次数为 1，再去释放这个线程，firstReader置空 ，否则减去重入次数</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若当前线程不是第一个读线程，那么首先会获取缓存计数器</span></span><br><span class="line">        <span class="comment">// 注：深层次去分析了源码发现 ：readHolds存储了每一个线程的HoldCounter，而HoldCounter中的count变量就是用来记录线程获得的写锁的个数。</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> ||</span><br><span class="line">            rh.tid != LockSupport.getThreadId(current)) <span class="comment">// 如果计数器为空或者 tid 不等于当前线程的 tid，则获取缓存计数器，</span></span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="comment">// 如果当前线程的计数器数量小于或者等于 1 的时候，移除当前线程的计数器，</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="comment">// 如果小于 1 的时候则抛出异常，</span></span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果正常获取到了当前线程计数器，则将计数数量减一</span></span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当其他线程读锁也在释放读锁，AQS 可能失败所以自旋重试</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT; <span class="comment">// 高 16 位 减一</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// AQS</span></span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IllegalMonitorStateException <span class="title">unmatchedUnlockException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IllegalMonitorStateException(</span><br><span class="line">        <span class="string">"attempt to unlock read lock, not locked by current thread"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">     *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">     *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">     *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">     *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">     *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">     *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">     *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">     * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">     *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">     *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current) <span class="comment">// 当没有线程持有写锁的时候就可以获取读锁</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 获取读锁失败后，线程进入等待队列</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c); <span class="comment">// 获取读锁的数量</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; <span class="comment">// 通过公平的策略判断，如果读锁不用阻塞</span></span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;  <span class="comment">// 读锁数量没有超出上限</span></span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123; <span class="comment">// 就去将读锁的资源数量加一，这个时候注意的是，由于读锁在高 16 位上。</span></span><br><span class="line">        <span class="comment">// 经过上一步，已经成功获取到读锁，后面进行相关设置</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current; <span class="comment">// 如果它是第一个获取到读锁的线程，则将 firstReader 指向它，并且计数读锁firstReader重入次数为1</span></span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++; <span class="comment">// 重入次数加一</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对于 不是 firstReader 读锁计数更新，更新当前线程的缓存</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> ||</span><br><span class="line">                rh.tid != LockSupport.getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取读锁失败（阻塞或者数量上限或者 AQS 设置失败），重试，跟 tryAcquireShared 差不多的逻辑。</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读读锁的时候需要注意<code>firstReader</code>，和 <code>HoldCounter</code> 这两个变量的变化就可以了：</p><ol><li>如果读锁没有被持有，那么每一个线程的 <code>HoldCounter</code> 变量中的 count 变量一定是为 0；</li><li>如果当前线程是第一个获取到读锁的线程，设置 <code>firstReader</code> 为当前线程，并且设置 <code>firstReadHoldCount</code>数量；</li><li>那么如果当前线程不是第一个获取读锁的线程，那么获取当前线程的 <code>HoldCounter</code>，获取 <code>count</code> 的值，判断它等不等于 0 ，如果等于 0 的话，表示当前线程没有获取读锁，那么可以从 <code>readHolds</code> 的管理中将它移除，</li></ol><h4 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h4><p><strong>锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</strong></p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>主要是分析 AQS 源码的实现，了解到所有的同步类都是实现自定义的同步器 <code>sync</code> ，实现独占方法或者共享方法中的获取资源和释放资源方法供自己使用，同步器只要关注资源变量 state 的变化，对使用者非常友好，层次分明，而不需要关注队列和线程的阻塞的情况。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li>《Java 并发编程的艺术》</li><li><a href="http://luojinping.com/2015/06/19/AbstractQueuedSynchronizer%E8%AF%A6%E8%A7%A3/" rel="external nofollow noopener noreferrer" target="_blank">AbstractQueuedSynchronizer详解</a></li><li><a href="http://www.cnblogs.com/waterystone/p/4920797.html" rel="external nofollow noopener noreferrer" target="_blank">Java并发之AQS详解</a></li><li><a href="https://www.jianshu.com/p/e2179c74a2e4?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=pc_all_hots&amp;utm_source=recommendation" rel="external nofollow noopener noreferrer" target="_blank">认识非阻塞的同步机制CAS</a></li><li><a href="http://www.cnblogs.com/thomaschen750215/p/4122068.html" rel="external nofollow noopener noreferrer" target="_blank">CAS和自旋锁(spin lock)</a></li><li><a href="https://www.jianshu.com/p/e3afe8ab8364" rel="external nofollow noopener noreferrer" target="_blank">LockSupport（park/unpark）源码分析</a></li><li><a href="https://blog.csdn.net/yuhongye111/article/details/39055531" rel="external nofollow noopener noreferrer" target="_blank">Java并发-ReentrantReadWriteLock源码分析</a></li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">------本文结束 🖐 感谢阅读------</div></div></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a> <a href="/tags/并发编程/" rel="tag"><i class="fa fa-tag"></i> 并发编程</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/java-hashcode.html" rel="next" title="Java 中 hashCode 的一些研究"><i class="fa fa-chevron-left"></i> Java 中 hashCode 的一些研究</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/juc-utils.html" rel="prev" title="Java 中的并发工具类">Java 中的并发工具类 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"><script>window._bd_share_config={common:{bdText:"",bdMini:"1",bdMiniList:!1,bdPic:""},image:{viewList:["tsina","douban","sqq","qzone","weixin","twi","fbook"],viewText:"分享到：",viewSize:"16"},slide:{bdImg:"5",bdPos:"left",bdTop:"100"}}</script><script>with(document)(0)[(getElementsByTagName("head")[0]||body).appendChild(createElement("script")).src="/static/api/js/share.js?v=89860593.js?cdnversion="+~(-new Date/36e5)]</script></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://oss.wuwii.com/image/head/%E6%97%A0%E9%99%90.jpg" alt="Kai Zhang"><p class="site-author-name" itemprop="name">Kai Zhang</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">192</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">74</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS </a><a title="收藏到书签，偶尔High一下^_^" rel="alternate external nofollow" class="mw-harlem_shake_slow wobble shake" href="javascript:go()"><i class="fa fa-music"></i> 听音乐</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/kaimz" target="_blank" title="GitHub" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="mailto:im.zhangk@qq.com" target="_blank" title="Email" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-envelope-o"></i> Email </a></span><span class="links-of-author-item"><a href="http://wpa.qq.com/msgrd?v=3&uin=1075199251&site=qq&menu=yes" target="_blank" title="QQ" rel="external nofollow noopener noreferrer"><i class="fa fa-fw fa-qq"></i> QQ</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-globe"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://weispring.github.io/" title="悦夏" target="_blank" rel="external nofollow noopener noreferrer">悦夏</a></li><li class="links-of-blogroll-item"><a href="http://sdll.club" title="闪电拉拉" target="_blank" rel="external nofollow noopener noreferrer">闪电拉拉</a></li><li class="links-of-blogroll-item"><a href="https://www.draw.io/" title="draw.io" target="_blank" rel="external nofollow noopener noreferrer">draw.io</a></li><li class="links-of-blogroll-item"><a href="https://www.processon.com/" title="processon" target="_blank" rel="external nofollow noopener noreferrer">processon</a></li><li class="links-of-blogroll-item"><a href="http://asciiflow.com/" title="asciiflow" target="_blank" rel="external nofollow noopener noreferrer">asciiflow</a></li><li class="links-of-blogroll-item"><a href="http://hui-wang.info/" title="王辉的博客" target="_blank" rel="external nofollow noopener noreferrer">王辉的博客</a></li><li class="links-of-blogroll-item"><a href="https://leetcode.com/" title="leetcode" target="_blank" rel="external nofollow noopener noreferrer">leetcode</a></li><li class="links-of-blogroll-item"><a href="http://www.lintcode.com/" title="lintcode" target="_blank" rel="external nofollow noopener noreferrer">lintcode</a></li><li class="links-of-blogroll-item"><a href="https://stackoverflow.com/" title="stackoverflow" target="_blank" rel="external nofollow noopener noreferrer">stackoverflow</a></li><li class="links-of-blogroll-item"><a href="http://www.importnew.com/" title="ImportNew" target="_blank" rel="external nofollow noopener noreferrer">ImportNew</a></li><li class="links-of-blogroll-item"><a href="http://ifeve.com/" title="ifeve" target="_blank" rel="external nofollow noopener noreferrer">ifeve</a></li><li class="links-of-blogroll-item"><a href="http://blog.720ui.com/" title="梁桂钊的博客" target="_blank" rel="external nofollow noopener noreferrer">梁桂钊的博客</a></li><li class="links-of-blogroll-item"><a href="http://www.itmuch.com/" title="Spring Cloud|周立" target="_blank" rel="external nofollow noopener noreferrer">Spring Cloud|周立</a></li><li class="links-of-blogroll-item"><a href="https://edu.aliyun.com/" title="阿里云大学" target="_blank" rel="external nofollow noopener noreferrer">阿里云大学</a></li><li class="links-of-blogroll-item"><a href="http://www.iocoder.cn/" title="「芋道源码」" target="_blank" rel="external nofollow noopener noreferrer">「芋道源码」</a></li><li class="links-of-blogroll-item"><a href="http://cmsblogs.com" title="cmsblogs" target="_blank" rel="external nofollow noopener noreferrer">cmsblogs</a></li><li class="links-of-blogroll-item"><a href="http://36kr.com/" title="36氪" target="_blank" rel="external nofollow noopener noreferrer">36氪</a></li><li class="links-of-blogroll-item"><a href="https://laod.cn/" title="老D博客" target="_blank" rel="external nofollow noopener noreferrer">老D博客</a></li><li class="links-of-blogroll-item"><a href="http://blog.didispace.com/" title="程序猿DD" target="_blank" rel="external nofollow noopener noreferrer">程序猿DD</a></li><li class="links-of-blogroll-item"><a href="http://www.bijishequ.com/" title="笔记社区" target="_blank" rel="external nofollow noopener noreferrer">笔记社区</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#分析-AQS（队列同步器）"><span class="nav-number">1.</span> <span class="nav-text">分析 AQS（队列同步器）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#怎么实现队列同步器"><span class="nav-number">1.1.</span> <span class="nav-text">怎么实现队列同步器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#独占模式"><span class="nav-number">1.2.</span> <span class="nav-text">独占模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#acquire"><span class="nav-number">1.2.1.</span> <span class="nav-text">acquire</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#release"><span class="nav-number">1.2.2.</span> <span class="nav-text">release</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结"><span class="nav-number">1.2.3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#doAcquireNanos"><span class="nav-number">1.2.4.</span> <span class="nav-text">doAcquireNanos</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享模式"><span class="nav-number">1.3.</span> <span class="nav-text">共享模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#acquireShared"><span class="nav-number">1.3.1.</span> <span class="nav-text">acquireShared</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#releaseShared"><span class="nav-number">1.3.2.</span> <span class="nav-text">releaseShared</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mutex（独占锁）"><span class="nav-number">1.4.</span> <span class="nav-text">Mutex（独占锁）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TwinsLock（共享锁）"><span class="nav-number">1.5.</span> <span class="nav-text">TwinsLock（共享锁）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-1"><span class="nav-number">1.6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#补充：CLH-队列锁"><span class="nav-number">1.7.</span> <span class="nav-text">补充：CLH 队列锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#补充：CAS"><span class="nav-number">1.8.</span> <span class="nav-text">补充：CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#补充：自旋锁"><span class="nav-number">1.9.</span> <span class="nav-text">补充：自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#补充：LockSupport"><span class="nav-number">1.10.</span> <span class="nav-text">补充：LockSupport</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock-独占锁"><span class="nav-number">2.</span> <span class="nav-text">ReentrantLock(独占锁)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#公平锁"><span class="nav-number">2.1.</span> <span class="nav-text">公平锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantReadWriteLock（读写锁）"><span class="nav-number">3.</span> <span class="nav-text">ReentrantReadWriteLock（读写锁）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法"><span class="nav-number">3.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读写状态设计"><span class="nav-number">3.2.</span> <span class="nav-text">读写状态设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步器的设计"><span class="nav-number">3.3.</span> <span class="nav-text">同步器的设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写锁的获取和释放"><span class="nav-number">3.4.</span> <span class="nav-text">写锁的获取和释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读锁的获取和释放"><span class="nav-number">3.5.</span> <span class="nav-text">读锁的获取和释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁降级"><span class="nav-number">3.6.</span> <span class="nav-text">锁降级</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文章"><span class="nav-number">5.</span> <span class="nav-text">参考文章</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2017 - <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="powered-by" itemprop="copyrightHolder">Kai Zhang</span> <span class="site-pv"><i class="fa fa-eye"></i> <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div><div class="powered-by">Hosted by <a href="https://pages.coding.me" rel="external nofollow noopener noreferrer" target="_blank">Coding Pages</a></div><i class="fa fa-bar-chart"></i><div class="theme-info" style="margin-left:8px"><span class="post-count">Site words total count:350.2k</span></div><script type="text/javascript" src="https://zqnight.gitee.io/kaimz.github.io/js/high.js"></script><script>!function(){var t="http:"==document.location.protocol?"http://js.passport.qihucdn.com/11.0.1.js?f62559b2127396ecb27f4ed4f4652ea1":"https://jspassport.ssl.qhimg.com/11.0.1.js?f62559b2127396ecb27f4ed4f4652ea1";document.write('<script src="'+t+'" id="sozz"><\/script>')}()</script><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;w<0&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/44968c17.js","daovoice"),daovoice("init",{app_id:"44968c17"}),daovoice("update")</script><script type="text/javascript" src="https://zqnight.gitee.io/kaimz.github.io/js/clipboard.min.js"></script><script type="text/javascript" src="https://zqnight.gitee.io/kaimz.github.io/js/copy.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/tororo.model.json"},display:{position:"left",width:100,height:200},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html><!-- rebuild by neat -->